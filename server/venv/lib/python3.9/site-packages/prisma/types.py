# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
            },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
            },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
            },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
            },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Organization types

class OrganizationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Organization create method"""
    OrganizationID: _int
    Description: Optional[_str]
    Website: Optional[_str]
    mentors: 'MentorCreateManyNestedWithoutRelationsInput'


class OrganizationCreateInput(OrganizationOptionalCreateInput):
    """Required arguments to the Organization create method"""
    Name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class OrganizationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Organization create method, without relations"""
    OrganizationID: _int
    Description: Optional[_str]
    Website: Optional[_str]


class OrganizationCreateWithoutRelationsInput(OrganizationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Organization create method, without relations"""
    Name: _str


class OrganizationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'OrganizationCreateWithoutRelationsInput'
    connect: 'OrganizationWhereUniqueInput'


class OrganizationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['OrganizationCreateWithoutRelationsInput', List['OrganizationCreateWithoutRelationsInput']]
    connect: Union['OrganizationWhereUniqueInput', List['OrganizationWhereUniqueInput']]


_OrganizationWhereUnique_OrganizationID_Input = TypedDict(
    '_OrganizationWhereUnique_OrganizationID_Input',
    {
        'OrganizationID': '_int',
    },
    total=True
)

OrganizationWhereUniqueInput = _OrganizationWhereUnique_OrganizationID_Input


class OrganizationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    OrganizationID: Union[AtomicIntInput, _int]
    Name: _str
    Description: Optional[_str]
    Website: Optional[_str]
    mentors: 'MentorUpdateManyWithoutRelationsInput'


class OrganizationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    OrganizationID: Union[AtomicIntInput, _int]
    Name: _str
    Description: Optional[_str]
    Website: Optional[_str]


class OrganizationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['OrganizationCreateWithoutRelationsInput']
    connect: List['OrganizationWhereUniqueInput']
    set: List['OrganizationWhereUniqueInput']
    disconnect: List['OrganizationWhereUniqueInput']
    delete: List['OrganizationWhereUniqueInput']

    # TODO
    # update: List['OrganizationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['OrganizationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['OrganizationScalarWhereInput']
    # upsert: List['OrganizationUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['OrganizationCreateOrConnectWithoutRelationsInput']


class OrganizationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'OrganizationCreateWithoutRelationsInput'
    connect: 'OrganizationWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'OrganizationUpdateInput'
    # upsert: 'OrganizationUpsertWithoutRelationsInput'
    # connectOrCreate: 'OrganizationCreateOrConnectWithoutRelationsInput'


class OrganizationUpsertInput(TypedDict):
    create: 'OrganizationCreateInput'
    update: 'OrganizationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Organization_OrganizationID_OrderByInput = TypedDict(
    '_Organization_OrganizationID_OrderByInput',
    {
        'OrganizationID': 'SortOrder',
    },
    total=True
)

_Organization_Name_OrderByInput = TypedDict(
    '_Organization_Name_OrderByInput',
    {
        'Name': 'SortOrder',
    },
    total=True
)

_Organization_Description_OrderByInput = TypedDict(
    '_Organization_Description_OrderByInput',
    {
        'Description': 'SortOrder',
    },
    total=True
)

_Organization_Website_OrderByInput = TypedDict(
    '_Organization_Website_OrderByInput',
    {
        'Website': 'SortOrder',
    },
    total=True
)

OrganizationOrderByInput = Union[
    '_Organization_OrganizationID_OrderByInput',
    '_Organization_Name_OrderByInput',
    '_Organization_Description_OrderByInput',
    '_Organization_Website_OrderByInput',
]



# recursive Organization types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

OrganizationRelationFilter = TypedDict(
    'OrganizationRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class OrganizationListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class OrganizationInclude(TypedDict, total=False):
    """Organization relational arguments"""
    mentors: Union[bool, 'FindManyMentorArgsFromOrganization']


    

class OrganizationIncludeFromOrganization(TypedDict, total=False):
    """Relational arguments for Organization"""
    mentors: Union[bool, 'FindManyMentorArgsFromOrganizationRecursive1']


class OrganizationIncludeFromOrganizationRecursive1(TypedDict, total=False):
    """Relational arguments for Organization"""
    mentors: Union[bool, 'FindManyMentorArgsFromOrganizationRecursive2']


class OrganizationIncludeFromOrganizationRecursive2(TypedDict, total=False):
    """Relational arguments for Organization"""
    mentors: Union[bool, 'FindManyMentorArgsFromOrganizationRecursive3']


class OrganizationIncludeFromOrganizationRecursive3(TypedDict, total=False):
    """Relational arguments for Organization"""
    mentors: Union[bool, 'FindManyMentorArgsFromOrganizationRecursive4']


class OrganizationIncludeFromOrganizationRecursive4(TypedDict, total=False):
    """Relational arguments for Organization"""

    

class OrganizationArgsFromOrganization(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'OrganizationIncludeFromOrganizationRecursive1'


class OrganizationArgsFromOrganizationRecursive1(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'OrganizationIncludeFromOrganizationRecursive2'


class OrganizationArgsFromOrganizationRecursive2(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'OrganizationIncludeFromOrganizationRecursive3'


class OrganizationArgsFromOrganizationRecursive3(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'OrganizationIncludeFromOrganizationRecursive4'


class OrganizationArgsFromOrganizationRecursive4(TypedDict, total=False):
    """Arguments for Organization"""
    
    

class FindManyOrganizationArgsFromOrganization(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive1'


class FindManyOrganizationArgsFromOrganizationRecursive1(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive2'


class FindManyOrganizationArgsFromOrganizationRecursive2(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive3'


class FindManyOrganizationArgsFromOrganizationRecursive3(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive4'


class FindManyOrganizationArgsFromOrganizationRecursive4(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    
    

class MentorIncludeFromOrganization(TypedDict, total=False):
    """Relational arguments for Organization"""
    organization: Union[bool, 'OrganizationArgsFromOrganizationRecursive1']
    students: Union[bool, 'FindManyStudentArgsFromOrganizationRecursive1']


class MentorIncludeFromOrganizationRecursive1(TypedDict, total=False):
    """Relational arguments for Organization"""
    organization: Union[bool, 'OrganizationArgsFromOrganizationRecursive2']
    students: Union[bool, 'FindManyStudentArgsFromOrganizationRecursive2']


class MentorIncludeFromOrganizationRecursive2(TypedDict, total=False):
    """Relational arguments for Organization"""
    organization: Union[bool, 'OrganizationArgsFromOrganizationRecursive3']
    students: Union[bool, 'FindManyStudentArgsFromOrganizationRecursive3']


class MentorIncludeFromOrganizationRecursive3(TypedDict, total=False):
    """Relational arguments for Organization"""
    organization: Union[bool, 'OrganizationArgsFromOrganizationRecursive4']
    students: Union[bool, 'FindManyStudentArgsFromOrganizationRecursive4']


class MentorIncludeFromOrganizationRecursive4(TypedDict, total=False):
    """Relational arguments for Organization"""

    

class MentorArgsFromOrganization(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'MentorIncludeFromMentorRecursive1'


class MentorArgsFromOrganizationRecursive1(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'MentorIncludeFromMentorRecursive2'


class MentorArgsFromOrganizationRecursive2(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'MentorIncludeFromMentorRecursive3'


class MentorArgsFromOrganizationRecursive3(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'MentorIncludeFromMentorRecursive4'


class MentorArgsFromOrganizationRecursive4(TypedDict, total=False):
    """Arguments for Organization"""
    
    

class FindManyMentorArgsFromOrganization(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive1'


class FindManyMentorArgsFromOrganizationRecursive1(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive2'


class FindManyMentorArgsFromOrganizationRecursive2(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive3'


class FindManyMentorArgsFromOrganizationRecursive3(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive4'


class FindManyMentorArgsFromOrganizationRecursive4(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    
    

class StudentIncludeFromOrganization(TypedDict, total=False):
    """Relational arguments for Organization"""
    mentor: Union[bool, 'MentorArgsFromOrganizationRecursive1']
    projects: Union[bool, 'FindManyStudentProjectArgsFromOrganizationRecursive1']


class StudentIncludeFromOrganizationRecursive1(TypedDict, total=False):
    """Relational arguments for Organization"""
    mentor: Union[bool, 'MentorArgsFromOrganizationRecursive2']
    projects: Union[bool, 'FindManyStudentProjectArgsFromOrganizationRecursive2']


class StudentIncludeFromOrganizationRecursive2(TypedDict, total=False):
    """Relational arguments for Organization"""
    mentor: Union[bool, 'MentorArgsFromOrganizationRecursive3']
    projects: Union[bool, 'FindManyStudentProjectArgsFromOrganizationRecursive3']


class StudentIncludeFromOrganizationRecursive3(TypedDict, total=False):
    """Relational arguments for Organization"""
    mentor: Union[bool, 'MentorArgsFromOrganizationRecursive4']
    projects: Union[bool, 'FindManyStudentProjectArgsFromOrganizationRecursive4']


class StudentIncludeFromOrganizationRecursive4(TypedDict, total=False):
    """Relational arguments for Organization"""

    

class StudentArgsFromOrganization(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'StudentIncludeFromStudentRecursive1'


class StudentArgsFromOrganizationRecursive1(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'StudentIncludeFromStudentRecursive2'


class StudentArgsFromOrganizationRecursive2(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'StudentIncludeFromStudentRecursive3'


class StudentArgsFromOrganizationRecursive3(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'StudentIncludeFromStudentRecursive4'


class StudentArgsFromOrganizationRecursive4(TypedDict, total=False):
    """Arguments for Organization"""
    
    

class FindManyStudentArgsFromOrganization(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive1'


class FindManyStudentArgsFromOrganizationRecursive1(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive2'


class FindManyStudentArgsFromOrganizationRecursive2(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive3'


class FindManyStudentArgsFromOrganizationRecursive3(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive4'


class FindManyStudentArgsFromOrganizationRecursive4(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    
    

class ProjectIncludeFromOrganization(TypedDict, total=False):
    """Relational arguments for Organization"""
    students: Union[bool, 'FindManyStudentProjectArgsFromOrganizationRecursive1']


class ProjectIncludeFromOrganizationRecursive1(TypedDict, total=False):
    """Relational arguments for Organization"""
    students: Union[bool, 'FindManyStudentProjectArgsFromOrganizationRecursive2']


class ProjectIncludeFromOrganizationRecursive2(TypedDict, total=False):
    """Relational arguments for Organization"""
    students: Union[bool, 'FindManyStudentProjectArgsFromOrganizationRecursive3']


class ProjectIncludeFromOrganizationRecursive3(TypedDict, total=False):
    """Relational arguments for Organization"""
    students: Union[bool, 'FindManyStudentProjectArgsFromOrganizationRecursive4']


class ProjectIncludeFromOrganizationRecursive4(TypedDict, total=False):
    """Relational arguments for Organization"""

    

class ProjectArgsFromOrganization(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromOrganizationRecursive1(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromOrganizationRecursive2(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromOrganizationRecursive3(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromOrganizationRecursive4(TypedDict, total=False):
    """Arguments for Organization"""
    
    

class FindManyProjectArgsFromOrganization(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromOrganizationRecursive1(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromOrganizationRecursive2(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromOrganizationRecursive3(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromOrganizationRecursive4(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class StudentProjectIncludeFromOrganization(TypedDict, total=False):
    """Relational arguments for Organization"""
    student: Union[bool, 'StudentArgsFromOrganizationRecursive1']
    project: Union[bool, 'ProjectArgsFromOrganizationRecursive1']


class StudentProjectIncludeFromOrganizationRecursive1(TypedDict, total=False):
    """Relational arguments for Organization"""
    student: Union[bool, 'StudentArgsFromOrganizationRecursive2']
    project: Union[bool, 'ProjectArgsFromOrganizationRecursive2']


class StudentProjectIncludeFromOrganizationRecursive2(TypedDict, total=False):
    """Relational arguments for Organization"""
    student: Union[bool, 'StudentArgsFromOrganizationRecursive3']
    project: Union[bool, 'ProjectArgsFromOrganizationRecursive3']


class StudentProjectIncludeFromOrganizationRecursive3(TypedDict, total=False):
    """Relational arguments for Organization"""
    student: Union[bool, 'StudentArgsFromOrganizationRecursive4']
    project: Union[bool, 'ProjectArgsFromOrganizationRecursive4']


class StudentProjectIncludeFromOrganizationRecursive4(TypedDict, total=False):
    """Relational arguments for Organization"""

    

class StudentProjectArgsFromOrganization(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive1'


class StudentProjectArgsFromOrganizationRecursive1(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive2'


class StudentProjectArgsFromOrganizationRecursive2(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive3'


class StudentProjectArgsFromOrganizationRecursive3(TypedDict, total=False):
    """Arguments for Organization"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive4'


class StudentProjectArgsFromOrganizationRecursive4(TypedDict, total=False):
    """Arguments for Organization"""
    
    

class FindManyStudentProjectArgsFromOrganization(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive1'


class FindManyStudentProjectArgsFromOrganizationRecursive1(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive2'


class FindManyStudentProjectArgsFromOrganizationRecursive2(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive3'


class FindManyStudentProjectArgsFromOrganizationRecursive3(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive4'


class FindManyStudentProjectArgsFromOrganizationRecursive4(TypedDict, total=False):
    """Arguments for Organization"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    


FindManyOrganizationArgs = FindManyOrganizationArgsFromOrganization
FindFirstOrganizationArgs = FindManyOrganizationArgsFromOrganization


    

class OrganizationWhereInput(TypedDict, total=False):
    """Organization arguments for searching"""
    OrganizationID: Union[_int, 'types.IntFilter']
    Name: Union[_str, 'types.StringFilter']
    Description: Union[None, _str, 'types.StringFilter']
    Website: Union[None, _str, 'types.StringFilter']
    mentors: 'MentorListRelationFilter'

    # should be noted that AND and NOT should be Union['OrganizationWhereInputRecursive1', List['OrganizationWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['OrganizationWhereInputRecursive1']
    OR: List['OrganizationWhereInputRecursive1']
    NOT: List['OrganizationWhereInputRecursive1']


class OrganizationWhereInputRecursive1(TypedDict, total=False):
    """Organization arguments for searching"""
    OrganizationID: Union[_int, 'types.IntFilter']
    Name: Union[_str, 'types.StringFilter']
    Description: Union[None, _str, 'types.StringFilter']
    Website: Union[None, _str, 'types.StringFilter']
    mentors: 'MentorListRelationFilter'

    # should be noted that AND and NOT should be Union['OrganizationWhereInputRecursive2', List['OrganizationWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['OrganizationWhereInputRecursive2']
    OR: List['OrganizationWhereInputRecursive2']
    NOT: List['OrganizationWhereInputRecursive2']


class OrganizationWhereInputRecursive2(TypedDict, total=False):
    """Organization arguments for searching"""
    OrganizationID: Union[_int, 'types.IntFilter']
    Name: Union[_str, 'types.StringFilter']
    Description: Union[None, _str, 'types.StringFilter']
    Website: Union[None, _str, 'types.StringFilter']
    mentors: 'MentorListRelationFilter'

    # should be noted that AND and NOT should be Union['OrganizationWhereInputRecursive3', List['OrganizationWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['OrganizationWhereInputRecursive3']
    OR: List['OrganizationWhereInputRecursive3']
    NOT: List['OrganizationWhereInputRecursive3']


class OrganizationWhereInputRecursive3(TypedDict, total=False):
    """Organization arguments for searching"""
    OrganizationID: Union[_int, 'types.IntFilter']
    Name: Union[_str, 'types.StringFilter']
    Description: Union[None, _str, 'types.StringFilter']
    Website: Union[None, _str, 'types.StringFilter']
    mentors: 'MentorListRelationFilter'

    # should be noted that AND and NOT should be Union['OrganizationWhereInputRecursive4', List['OrganizationWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['OrganizationWhereInputRecursive4']
    OR: List['OrganizationWhereInputRecursive4']
    NOT: List['OrganizationWhereInputRecursive4']


class OrganizationWhereInputRecursive4(TypedDict, total=False):
    """Organization arguments for searching"""
    OrganizationID: Union[_int, 'types.IntFilter']
    Name: Union[_str, 'types.StringFilter']
    Description: Union[None, _str, 'types.StringFilter']
    Website: Union[None, _str, 'types.StringFilter']
    mentors: 'MentorListRelationFilter'



# aggregate Organization types


    

class OrganizationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Organization arguments for searching"""
    OrganizationID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    Description: Union[_str, 'types.StringWithAggregatesFilter']
    Website: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['OrganizationScalarWhereWithAggregatesInputRecursive1']
    OR: List['OrganizationScalarWhereWithAggregatesInputRecursive1']
    NOT: List['OrganizationScalarWhereWithAggregatesInputRecursive1']


class OrganizationScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Organization arguments for searching"""
    OrganizationID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    Description: Union[_str, 'types.StringWithAggregatesFilter']
    Website: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['OrganizationScalarWhereWithAggregatesInputRecursive2']
    OR: List['OrganizationScalarWhereWithAggregatesInputRecursive2']
    NOT: List['OrganizationScalarWhereWithAggregatesInputRecursive2']


class OrganizationScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Organization arguments for searching"""
    OrganizationID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    Description: Union[_str, 'types.StringWithAggregatesFilter']
    Website: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['OrganizationScalarWhereWithAggregatesInputRecursive3']
    OR: List['OrganizationScalarWhereWithAggregatesInputRecursive3']
    NOT: List['OrganizationScalarWhereWithAggregatesInputRecursive3']


class OrganizationScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Organization arguments for searching"""
    OrganizationID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    Description: Union[_str, 'types.StringWithAggregatesFilter']
    Website: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['OrganizationScalarWhereWithAggregatesInputRecursive4']
    OR: List['OrganizationScalarWhereWithAggregatesInputRecursive4']
    NOT: List['OrganizationScalarWhereWithAggregatesInputRecursive4']


class OrganizationScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Organization arguments for searching"""
    OrganizationID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    Description: Union[_str, 'types.StringWithAggregatesFilter']
    Website: Union[_str, 'types.StringWithAggregatesFilter']



class OrganizationGroupByOutput(TypedDict, total=False):
    OrganizationID: _int
    Name: _str
    Description: _str
    Website: _str
    _sum: 'OrganizationSumAggregateOutput'
    _avg: 'OrganizationAvgAggregateOutput'
    _min: 'OrganizationMinAggregateOutput'
    _max: 'OrganizationMaxAggregateOutput'
    _count: 'OrganizationCountAggregateOutput'


class OrganizationAvgAggregateOutput(TypedDict, total=False):
    """Organization output for aggregating averages"""
    OrganizationID: float


class OrganizationSumAggregateOutput(TypedDict, total=False):
    """Organization output for aggregating sums"""
    OrganizationID: _int


class OrganizationScalarAggregateOutput(TypedDict, total=False):
    """Organization output including scalar fields"""
    OrganizationID: _int
    Name: _str
    Description: _str
    Website: _str


OrganizationMinAggregateOutput = OrganizationScalarAggregateOutput
OrganizationMaxAggregateOutput = OrganizationScalarAggregateOutput


class OrganizationMaxAggregateInput(TypedDict, total=False):
    """Organization input for aggregating by max"""
    OrganizationID: bool
    Name: bool
    Description: bool
    Website: bool


class OrganizationMinAggregateInput(TypedDict, total=False):
    """Organization input for aggregating by min"""
    OrganizationID: bool
    Name: bool
    Description: bool
    Website: bool


class OrganizationNumberAggregateInput(TypedDict, total=False):
    """Organization input for aggregating numbers"""
    OrganizationID: bool


OrganizationAvgAggregateInput = OrganizationNumberAggregateInput
OrganizationSumAggregateInput = OrganizationNumberAggregateInput


OrganizationCountAggregateInput = TypedDict(
    'OrganizationCountAggregateInput',
    {
        'OrganizationID': bool,
        'Name': bool,
        'Description': bool,
        'Website': bool,
        '_all': bool,
    },
    total=False,
)

OrganizationCountAggregateOutput = TypedDict(
    'OrganizationCountAggregateOutput',
    {
        'OrganizationID': int,
        'Name': int,
        'Description': int,
        'Website': int,
        '_all': int,
    },
    total=False,
)


OrganizationKeys = Literal[
    'OrganizationID',
    'Name',
    'Description',
    'Website',
    'mentors',
]
OrganizationScalarFieldKeys = Literal[
    'OrganizationID',
    'Name',
    'Description',
    'Website',
]
OrganizationScalarFieldKeysT = TypeVar('OrganizationScalarFieldKeysT', bound=OrganizationScalarFieldKeys)

OrganizationRelationalFieldKeys = Literal[
        'mentors',
    ]

# Mentor types

class MentorOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Mentor create method"""
    Name: Optional[_str]
    eMail: Optional[_str]
    Mobile: Optional[_str]
    Specialization: Optional[_str]
    Availability: Optional[_str]
    LinkedIn: Optional[_str]
    OrganizationID: Optional[_int]
    organization: 'OrganizationCreateNestedWithoutRelationsInput'
    students: 'StudentCreateManyNestedWithoutRelationsInput'


class MentorCreateInput(MentorOptionalCreateInput):
    """Required arguments to the Mentor create method"""
    MentorID: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MentorOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Mentor create method, without relations"""
    Name: Optional[_str]
    eMail: Optional[_str]
    Mobile: Optional[_str]
    Specialization: Optional[_str]
    Availability: Optional[_str]
    LinkedIn: Optional[_str]
    OrganizationID: Optional[_int]


class MentorCreateWithoutRelationsInput(MentorOptionalCreateWithoutRelationsInput):
    """Required arguments to the Mentor create method, without relations"""
    MentorID: _int


class MentorCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MentorCreateWithoutRelationsInput'
    connect: 'MentorWhereUniqueInput'


class MentorCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MentorCreateWithoutRelationsInput', List['MentorCreateWithoutRelationsInput']]
    connect: Union['MentorWhereUniqueInput', List['MentorWhereUniqueInput']]


_MentorWhereUnique_MentorID_Input = TypedDict(
    '_MentorWhereUnique_MentorID_Input',
    {
        'MentorID': '_int',
    },
    total=True
)

_MentorWhereUnique_eMail_Input = TypedDict(
    '_MentorWhereUnique_eMail_Input',
    {
        'eMail': '_str',
    },
    total=True
)

MentorWhereUniqueInput = Union[
    '_MentorWhereUnique_MentorID_Input',
    '_MentorWhereUnique_eMail_Input',
]


class MentorUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    MentorID: Union[AtomicIntInput, _int]
    Name: Optional[_str]
    eMail: Optional[_str]
    Mobile: Optional[_str]
    Specialization: Optional[_str]
    Availability: Optional[_str]
    LinkedIn: Optional[_str]
    organization: 'OrganizationUpdateOneWithoutRelationsInput'
    students: 'StudentUpdateManyWithoutRelationsInput'


class MentorUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    MentorID: Union[AtomicIntInput, _int]
    Name: Optional[_str]
    eMail: Optional[_str]
    Mobile: Optional[_str]
    Specialization: Optional[_str]
    Availability: Optional[_str]
    LinkedIn: Optional[_str]


class MentorUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MentorCreateWithoutRelationsInput']
    connect: List['MentorWhereUniqueInput']
    set: List['MentorWhereUniqueInput']
    disconnect: List['MentorWhereUniqueInput']
    delete: List['MentorWhereUniqueInput']

    # TODO
    # update: List['MentorUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MentorUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MentorScalarWhereInput']
    # upsert: List['MentorUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['MentorCreateOrConnectWithoutRelationsInput']


class MentorUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MentorCreateWithoutRelationsInput'
    connect: 'MentorWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MentorUpdateInput'
    # upsert: 'MentorUpsertWithoutRelationsInput'
    # connectOrCreate: 'MentorCreateOrConnectWithoutRelationsInput'


class MentorUpsertInput(TypedDict):
    create: 'MentorCreateInput'
    update: 'MentorUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Mentor_MentorID_OrderByInput = TypedDict(
    '_Mentor_MentorID_OrderByInput',
    {
        'MentorID': 'SortOrder',
    },
    total=True
)

_Mentor_Name_OrderByInput = TypedDict(
    '_Mentor_Name_OrderByInput',
    {
        'Name': 'SortOrder',
    },
    total=True
)

_Mentor_eMail_OrderByInput = TypedDict(
    '_Mentor_eMail_OrderByInput',
    {
        'eMail': 'SortOrder',
    },
    total=True
)

_Mentor_Mobile_OrderByInput = TypedDict(
    '_Mentor_Mobile_OrderByInput',
    {
        'Mobile': 'SortOrder',
    },
    total=True
)

_Mentor_Specialization_OrderByInput = TypedDict(
    '_Mentor_Specialization_OrderByInput',
    {
        'Specialization': 'SortOrder',
    },
    total=True
)

_Mentor_Availability_OrderByInput = TypedDict(
    '_Mentor_Availability_OrderByInput',
    {
        'Availability': 'SortOrder',
    },
    total=True
)

_Mentor_LinkedIn_OrderByInput = TypedDict(
    '_Mentor_LinkedIn_OrderByInput',
    {
        'LinkedIn': 'SortOrder',
    },
    total=True
)

_Mentor_OrganizationID_OrderByInput = TypedDict(
    '_Mentor_OrganizationID_OrderByInput',
    {
        'OrganizationID': 'SortOrder',
    },
    total=True
)

MentorOrderByInput = Union[
    '_Mentor_MentorID_OrderByInput',
    '_Mentor_Name_OrderByInput',
    '_Mentor_eMail_OrderByInput',
    '_Mentor_Mobile_OrderByInput',
    '_Mentor_Specialization_OrderByInput',
    '_Mentor_Availability_OrderByInput',
    '_Mentor_LinkedIn_OrderByInput',
    '_Mentor_OrganizationID_OrderByInput',
]



# recursive Mentor types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

MentorRelationFilter = TypedDict(
    'MentorRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class MentorListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class MentorInclude(TypedDict, total=False):
    """Mentor relational arguments"""
    organization: Union[bool, 'OrganizationArgsFromMentor']
    students: Union[bool, 'FindManyStudentArgsFromMentor']


    

class OrganizationIncludeFromMentor(TypedDict, total=False):
    """Relational arguments for Mentor"""
    mentors: Union[bool, 'FindManyMentorArgsFromMentorRecursive1']


class OrganizationIncludeFromMentorRecursive1(TypedDict, total=False):
    """Relational arguments for Mentor"""
    mentors: Union[bool, 'FindManyMentorArgsFromMentorRecursive2']


class OrganizationIncludeFromMentorRecursive2(TypedDict, total=False):
    """Relational arguments for Mentor"""
    mentors: Union[bool, 'FindManyMentorArgsFromMentorRecursive3']


class OrganizationIncludeFromMentorRecursive3(TypedDict, total=False):
    """Relational arguments for Mentor"""
    mentors: Union[bool, 'FindManyMentorArgsFromMentorRecursive4']


class OrganizationIncludeFromMentorRecursive4(TypedDict, total=False):
    """Relational arguments for Mentor"""

    

class OrganizationArgsFromMentor(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'OrganizationIncludeFromOrganizationRecursive1'


class OrganizationArgsFromMentorRecursive1(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'OrganizationIncludeFromOrganizationRecursive2'


class OrganizationArgsFromMentorRecursive2(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'OrganizationIncludeFromOrganizationRecursive3'


class OrganizationArgsFromMentorRecursive3(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'OrganizationIncludeFromOrganizationRecursive4'


class OrganizationArgsFromMentorRecursive4(TypedDict, total=False):
    """Arguments for Mentor"""
    
    

class FindManyOrganizationArgsFromMentor(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive1'


class FindManyOrganizationArgsFromMentorRecursive1(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive2'


class FindManyOrganizationArgsFromMentorRecursive2(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive3'


class FindManyOrganizationArgsFromMentorRecursive3(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive4'


class FindManyOrganizationArgsFromMentorRecursive4(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    
    

class MentorIncludeFromMentor(TypedDict, total=False):
    """Relational arguments for Mentor"""
    organization: Union[bool, 'OrganizationArgsFromMentorRecursive1']
    students: Union[bool, 'FindManyStudentArgsFromMentorRecursive1']


class MentorIncludeFromMentorRecursive1(TypedDict, total=False):
    """Relational arguments for Mentor"""
    organization: Union[bool, 'OrganizationArgsFromMentorRecursive2']
    students: Union[bool, 'FindManyStudentArgsFromMentorRecursive2']


class MentorIncludeFromMentorRecursive2(TypedDict, total=False):
    """Relational arguments for Mentor"""
    organization: Union[bool, 'OrganizationArgsFromMentorRecursive3']
    students: Union[bool, 'FindManyStudentArgsFromMentorRecursive3']


class MentorIncludeFromMentorRecursive3(TypedDict, total=False):
    """Relational arguments for Mentor"""
    organization: Union[bool, 'OrganizationArgsFromMentorRecursive4']
    students: Union[bool, 'FindManyStudentArgsFromMentorRecursive4']


class MentorIncludeFromMentorRecursive4(TypedDict, total=False):
    """Relational arguments for Mentor"""

    

class MentorArgsFromMentor(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'MentorIncludeFromMentorRecursive1'


class MentorArgsFromMentorRecursive1(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'MentorIncludeFromMentorRecursive2'


class MentorArgsFromMentorRecursive2(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'MentorIncludeFromMentorRecursive3'


class MentorArgsFromMentorRecursive3(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'MentorIncludeFromMentorRecursive4'


class MentorArgsFromMentorRecursive4(TypedDict, total=False):
    """Arguments for Mentor"""
    
    

class FindManyMentorArgsFromMentor(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive1'


class FindManyMentorArgsFromMentorRecursive1(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive2'


class FindManyMentorArgsFromMentorRecursive2(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive3'


class FindManyMentorArgsFromMentorRecursive3(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive4'


class FindManyMentorArgsFromMentorRecursive4(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    
    

class StudentIncludeFromMentor(TypedDict, total=False):
    """Relational arguments for Mentor"""
    mentor: Union[bool, 'MentorArgsFromMentorRecursive1']
    projects: Union[bool, 'FindManyStudentProjectArgsFromMentorRecursive1']


class StudentIncludeFromMentorRecursive1(TypedDict, total=False):
    """Relational arguments for Mentor"""
    mentor: Union[bool, 'MentorArgsFromMentorRecursive2']
    projects: Union[bool, 'FindManyStudentProjectArgsFromMentorRecursive2']


class StudentIncludeFromMentorRecursive2(TypedDict, total=False):
    """Relational arguments for Mentor"""
    mentor: Union[bool, 'MentorArgsFromMentorRecursive3']
    projects: Union[bool, 'FindManyStudentProjectArgsFromMentorRecursive3']


class StudentIncludeFromMentorRecursive3(TypedDict, total=False):
    """Relational arguments for Mentor"""
    mentor: Union[bool, 'MentorArgsFromMentorRecursive4']
    projects: Union[bool, 'FindManyStudentProjectArgsFromMentorRecursive4']


class StudentIncludeFromMentorRecursive4(TypedDict, total=False):
    """Relational arguments for Mentor"""

    

class StudentArgsFromMentor(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'StudentIncludeFromStudentRecursive1'


class StudentArgsFromMentorRecursive1(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'StudentIncludeFromStudentRecursive2'


class StudentArgsFromMentorRecursive2(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'StudentIncludeFromStudentRecursive3'


class StudentArgsFromMentorRecursive3(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'StudentIncludeFromStudentRecursive4'


class StudentArgsFromMentorRecursive4(TypedDict, total=False):
    """Arguments for Mentor"""
    
    

class FindManyStudentArgsFromMentor(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive1'


class FindManyStudentArgsFromMentorRecursive1(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive2'


class FindManyStudentArgsFromMentorRecursive2(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive3'


class FindManyStudentArgsFromMentorRecursive3(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive4'


class FindManyStudentArgsFromMentorRecursive4(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    
    

class ProjectIncludeFromMentor(TypedDict, total=False):
    """Relational arguments for Mentor"""
    students: Union[bool, 'FindManyStudentProjectArgsFromMentorRecursive1']


class ProjectIncludeFromMentorRecursive1(TypedDict, total=False):
    """Relational arguments for Mentor"""
    students: Union[bool, 'FindManyStudentProjectArgsFromMentorRecursive2']


class ProjectIncludeFromMentorRecursive2(TypedDict, total=False):
    """Relational arguments for Mentor"""
    students: Union[bool, 'FindManyStudentProjectArgsFromMentorRecursive3']


class ProjectIncludeFromMentorRecursive3(TypedDict, total=False):
    """Relational arguments for Mentor"""
    students: Union[bool, 'FindManyStudentProjectArgsFromMentorRecursive4']


class ProjectIncludeFromMentorRecursive4(TypedDict, total=False):
    """Relational arguments for Mentor"""

    

class ProjectArgsFromMentor(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromMentorRecursive1(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromMentorRecursive2(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromMentorRecursive3(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromMentorRecursive4(TypedDict, total=False):
    """Arguments for Mentor"""
    
    

class FindManyProjectArgsFromMentor(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromMentorRecursive1(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromMentorRecursive2(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromMentorRecursive3(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromMentorRecursive4(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class StudentProjectIncludeFromMentor(TypedDict, total=False):
    """Relational arguments for Mentor"""
    student: Union[bool, 'StudentArgsFromMentorRecursive1']
    project: Union[bool, 'ProjectArgsFromMentorRecursive1']


class StudentProjectIncludeFromMentorRecursive1(TypedDict, total=False):
    """Relational arguments for Mentor"""
    student: Union[bool, 'StudentArgsFromMentorRecursive2']
    project: Union[bool, 'ProjectArgsFromMentorRecursive2']


class StudentProjectIncludeFromMentorRecursive2(TypedDict, total=False):
    """Relational arguments for Mentor"""
    student: Union[bool, 'StudentArgsFromMentorRecursive3']
    project: Union[bool, 'ProjectArgsFromMentorRecursive3']


class StudentProjectIncludeFromMentorRecursive3(TypedDict, total=False):
    """Relational arguments for Mentor"""
    student: Union[bool, 'StudentArgsFromMentorRecursive4']
    project: Union[bool, 'ProjectArgsFromMentorRecursive4']


class StudentProjectIncludeFromMentorRecursive4(TypedDict, total=False):
    """Relational arguments for Mentor"""

    

class StudentProjectArgsFromMentor(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive1'


class StudentProjectArgsFromMentorRecursive1(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive2'


class StudentProjectArgsFromMentorRecursive2(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive3'


class StudentProjectArgsFromMentorRecursive3(TypedDict, total=False):
    """Arguments for Mentor"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive4'


class StudentProjectArgsFromMentorRecursive4(TypedDict, total=False):
    """Arguments for Mentor"""
    
    

class FindManyStudentProjectArgsFromMentor(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive1'


class FindManyStudentProjectArgsFromMentorRecursive1(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive2'


class FindManyStudentProjectArgsFromMentorRecursive2(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive3'


class FindManyStudentProjectArgsFromMentorRecursive3(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive4'


class FindManyStudentProjectArgsFromMentorRecursive4(TypedDict, total=False):
    """Arguments for Mentor"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    


FindManyMentorArgs = FindManyMentorArgsFromMentor
FindFirstMentorArgs = FindManyMentorArgsFromMentor


    

class MentorWhereInput(TypedDict, total=False):
    """Mentor arguments for searching"""
    MentorID: Union[_int, 'types.IntFilter']
    Name: Union[None, _str, 'types.StringFilter']
    eMail: Union[None, _str, 'types.StringFilter']
    Mobile: Union[None, _str, 'types.StringFilter']
    Specialization: Union[None, _str, 'types.StringFilter']
    Availability: Union[None, _str, 'types.StringFilter']
    LinkedIn: Union[None, _str, 'types.StringFilter']
    OrganizationID: Union[None, _int, 'types.IntFilter']
    organization: 'OrganizationRelationFilter'
    students: 'StudentListRelationFilter'

    # should be noted that AND and NOT should be Union['MentorWhereInputRecursive1', List['MentorWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['MentorWhereInputRecursive1']
    OR: List['MentorWhereInputRecursive1']
    NOT: List['MentorWhereInputRecursive1']


class MentorWhereInputRecursive1(TypedDict, total=False):
    """Mentor arguments for searching"""
    MentorID: Union[_int, 'types.IntFilter']
    Name: Union[None, _str, 'types.StringFilter']
    eMail: Union[None, _str, 'types.StringFilter']
    Mobile: Union[None, _str, 'types.StringFilter']
    Specialization: Union[None, _str, 'types.StringFilter']
    Availability: Union[None, _str, 'types.StringFilter']
    LinkedIn: Union[None, _str, 'types.StringFilter']
    OrganizationID: Union[None, _int, 'types.IntFilter']
    organization: 'OrganizationRelationFilter'
    students: 'StudentListRelationFilter'

    # should be noted that AND and NOT should be Union['MentorWhereInputRecursive2', List['MentorWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['MentorWhereInputRecursive2']
    OR: List['MentorWhereInputRecursive2']
    NOT: List['MentorWhereInputRecursive2']


class MentorWhereInputRecursive2(TypedDict, total=False):
    """Mentor arguments for searching"""
    MentorID: Union[_int, 'types.IntFilter']
    Name: Union[None, _str, 'types.StringFilter']
    eMail: Union[None, _str, 'types.StringFilter']
    Mobile: Union[None, _str, 'types.StringFilter']
    Specialization: Union[None, _str, 'types.StringFilter']
    Availability: Union[None, _str, 'types.StringFilter']
    LinkedIn: Union[None, _str, 'types.StringFilter']
    OrganizationID: Union[None, _int, 'types.IntFilter']
    organization: 'OrganizationRelationFilter'
    students: 'StudentListRelationFilter'

    # should be noted that AND and NOT should be Union['MentorWhereInputRecursive3', List['MentorWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['MentorWhereInputRecursive3']
    OR: List['MentorWhereInputRecursive3']
    NOT: List['MentorWhereInputRecursive3']


class MentorWhereInputRecursive3(TypedDict, total=False):
    """Mentor arguments for searching"""
    MentorID: Union[_int, 'types.IntFilter']
    Name: Union[None, _str, 'types.StringFilter']
    eMail: Union[None, _str, 'types.StringFilter']
    Mobile: Union[None, _str, 'types.StringFilter']
    Specialization: Union[None, _str, 'types.StringFilter']
    Availability: Union[None, _str, 'types.StringFilter']
    LinkedIn: Union[None, _str, 'types.StringFilter']
    OrganizationID: Union[None, _int, 'types.IntFilter']
    organization: 'OrganizationRelationFilter'
    students: 'StudentListRelationFilter'

    # should be noted that AND and NOT should be Union['MentorWhereInputRecursive4', List['MentorWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['MentorWhereInputRecursive4']
    OR: List['MentorWhereInputRecursive4']
    NOT: List['MentorWhereInputRecursive4']


class MentorWhereInputRecursive4(TypedDict, total=False):
    """Mentor arguments for searching"""
    MentorID: Union[_int, 'types.IntFilter']
    Name: Union[None, _str, 'types.StringFilter']
    eMail: Union[None, _str, 'types.StringFilter']
    Mobile: Union[None, _str, 'types.StringFilter']
    Specialization: Union[None, _str, 'types.StringFilter']
    Availability: Union[None, _str, 'types.StringFilter']
    LinkedIn: Union[None, _str, 'types.StringFilter']
    OrganizationID: Union[None, _int, 'types.IntFilter']
    organization: 'OrganizationRelationFilter'
    students: 'StudentListRelationFilter'



# aggregate Mentor types


    

class MentorScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Mentor arguments for searching"""
    MentorID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    eMail: Union[_str, 'types.StringWithAggregatesFilter']
    Mobile: Union[_str, 'types.StringWithAggregatesFilter']
    Specialization: Union[_str, 'types.StringWithAggregatesFilter']
    Availability: Union[_str, 'types.StringWithAggregatesFilter']
    LinkedIn: Union[_str, 'types.StringWithAggregatesFilter']
    OrganizationID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MentorScalarWhereWithAggregatesInputRecursive1']
    OR: List['MentorScalarWhereWithAggregatesInputRecursive1']
    NOT: List['MentorScalarWhereWithAggregatesInputRecursive1']


class MentorScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Mentor arguments for searching"""
    MentorID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    eMail: Union[_str, 'types.StringWithAggregatesFilter']
    Mobile: Union[_str, 'types.StringWithAggregatesFilter']
    Specialization: Union[_str, 'types.StringWithAggregatesFilter']
    Availability: Union[_str, 'types.StringWithAggregatesFilter']
    LinkedIn: Union[_str, 'types.StringWithAggregatesFilter']
    OrganizationID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MentorScalarWhereWithAggregatesInputRecursive2']
    OR: List['MentorScalarWhereWithAggregatesInputRecursive2']
    NOT: List['MentorScalarWhereWithAggregatesInputRecursive2']


class MentorScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Mentor arguments for searching"""
    MentorID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    eMail: Union[_str, 'types.StringWithAggregatesFilter']
    Mobile: Union[_str, 'types.StringWithAggregatesFilter']
    Specialization: Union[_str, 'types.StringWithAggregatesFilter']
    Availability: Union[_str, 'types.StringWithAggregatesFilter']
    LinkedIn: Union[_str, 'types.StringWithAggregatesFilter']
    OrganizationID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MentorScalarWhereWithAggregatesInputRecursive3']
    OR: List['MentorScalarWhereWithAggregatesInputRecursive3']
    NOT: List['MentorScalarWhereWithAggregatesInputRecursive3']


class MentorScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Mentor arguments for searching"""
    MentorID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    eMail: Union[_str, 'types.StringWithAggregatesFilter']
    Mobile: Union[_str, 'types.StringWithAggregatesFilter']
    Specialization: Union[_str, 'types.StringWithAggregatesFilter']
    Availability: Union[_str, 'types.StringWithAggregatesFilter']
    LinkedIn: Union[_str, 'types.StringWithAggregatesFilter']
    OrganizationID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MentorScalarWhereWithAggregatesInputRecursive4']
    OR: List['MentorScalarWhereWithAggregatesInputRecursive4']
    NOT: List['MentorScalarWhereWithAggregatesInputRecursive4']


class MentorScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Mentor arguments for searching"""
    MentorID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    eMail: Union[_str, 'types.StringWithAggregatesFilter']
    Mobile: Union[_str, 'types.StringWithAggregatesFilter']
    Specialization: Union[_str, 'types.StringWithAggregatesFilter']
    Availability: Union[_str, 'types.StringWithAggregatesFilter']
    LinkedIn: Union[_str, 'types.StringWithAggregatesFilter']
    OrganizationID: Union[_int, 'types.IntWithAggregatesFilter']



class MentorGroupByOutput(TypedDict, total=False):
    MentorID: _int
    Name: _str
    eMail: _str
    Mobile: _str
    Specialization: _str
    Availability: _str
    LinkedIn: _str
    OrganizationID: _int
    _sum: 'MentorSumAggregateOutput'
    _avg: 'MentorAvgAggregateOutput'
    _min: 'MentorMinAggregateOutput'
    _max: 'MentorMaxAggregateOutput'
    _count: 'MentorCountAggregateOutput'


class MentorAvgAggregateOutput(TypedDict, total=False):
    """Mentor output for aggregating averages"""
    MentorID: float
    OrganizationID: float


class MentorSumAggregateOutput(TypedDict, total=False):
    """Mentor output for aggregating sums"""
    MentorID: _int
    OrganizationID: _int


class MentorScalarAggregateOutput(TypedDict, total=False):
    """Mentor output including scalar fields"""
    MentorID: _int
    Name: _str
    eMail: _str
    Mobile: _str
    Specialization: _str
    Availability: _str
    LinkedIn: _str
    OrganizationID: _int


MentorMinAggregateOutput = MentorScalarAggregateOutput
MentorMaxAggregateOutput = MentorScalarAggregateOutput


class MentorMaxAggregateInput(TypedDict, total=False):
    """Mentor input for aggregating by max"""
    MentorID: bool
    Name: bool
    eMail: bool
    Mobile: bool
    Specialization: bool
    Availability: bool
    LinkedIn: bool
    OrganizationID: bool


class MentorMinAggregateInput(TypedDict, total=False):
    """Mentor input for aggregating by min"""
    MentorID: bool
    Name: bool
    eMail: bool
    Mobile: bool
    Specialization: bool
    Availability: bool
    LinkedIn: bool
    OrganizationID: bool


class MentorNumberAggregateInput(TypedDict, total=False):
    """Mentor input for aggregating numbers"""
    MentorID: bool
    OrganizationID: bool


MentorAvgAggregateInput = MentorNumberAggregateInput
MentorSumAggregateInput = MentorNumberAggregateInput


MentorCountAggregateInput = TypedDict(
    'MentorCountAggregateInput',
    {
        'MentorID': bool,
        'Name': bool,
        'eMail': bool,
        'Mobile': bool,
        'Specialization': bool,
        'Availability': bool,
        'LinkedIn': bool,
        'OrganizationID': bool,
        '_all': bool,
    },
    total=False,
)

MentorCountAggregateOutput = TypedDict(
    'MentorCountAggregateOutput',
    {
        'MentorID': int,
        'Name': int,
        'eMail': int,
        'Mobile': int,
        'Specialization': int,
        'Availability': int,
        'LinkedIn': int,
        'OrganizationID': int,
        '_all': int,
    },
    total=False,
)


MentorKeys = Literal[
    'MentorID',
    'Name',
    'eMail',
    'Mobile',
    'Specialization',
    'Availability',
    'LinkedIn',
    'OrganizationID',
    'organization',
    'students',
]
MentorScalarFieldKeys = Literal[
    'MentorID',
    'Name',
    'eMail',
    'Mobile',
    'Specialization',
    'Availability',
    'LinkedIn',
    'OrganizationID',
]
MentorScalarFieldKeysT = TypeVar('MentorScalarFieldKeysT', bound=MentorScalarFieldKeys)

MentorRelationalFieldKeys = Literal[
        'organization',
        'students',
    ]

# Student types

class StudentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Student create method"""
    Name: Optional[_str]
    eMail: Optional[_str]
    Mobile: Optional[_str]
    College: Optional[_str]
    Yr_Start: Optional[_int]
    Yr_End: Optional[_int]
    Degree: Optional[_str]
    Branch: Optional[_str]
    Electives: Optional[_str]
    Interests: Optional[_str]
    MentorID: Optional[_int]
    mentor: 'MentorCreateNestedWithoutRelationsInput'
    projects: 'StudentProjectCreateManyNestedWithoutRelationsInput'


class StudentCreateInput(StudentOptionalCreateInput):
    """Required arguments to the Student create method"""
    ID: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class StudentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Student create method, without relations"""
    Name: Optional[_str]
    eMail: Optional[_str]
    Mobile: Optional[_str]
    College: Optional[_str]
    Yr_Start: Optional[_int]
    Yr_End: Optional[_int]
    Degree: Optional[_str]
    Branch: Optional[_str]
    Electives: Optional[_str]
    Interests: Optional[_str]
    MentorID: Optional[_int]


class StudentCreateWithoutRelationsInput(StudentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Student create method, without relations"""
    ID: _int


class StudentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'StudentCreateWithoutRelationsInput'
    connect: 'StudentWhereUniqueInput'


class StudentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['StudentCreateWithoutRelationsInput', List['StudentCreateWithoutRelationsInput']]
    connect: Union['StudentWhereUniqueInput', List['StudentWhereUniqueInput']]


_StudentWhereUnique_ID_Input = TypedDict(
    '_StudentWhereUnique_ID_Input',
    {
        'ID': '_int',
    },
    total=True
)

_StudentWhereUnique_eMail_Input = TypedDict(
    '_StudentWhereUnique_eMail_Input',
    {
        'eMail': '_str',
    },
    total=True
)

StudentWhereUniqueInput = Union[
    '_StudentWhereUnique_ID_Input',
    '_StudentWhereUnique_eMail_Input',
]


class StudentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    ID: Union[AtomicIntInput, _int]
    Name: Optional[_str]
    eMail: Optional[_str]
    Mobile: Optional[_str]
    College: Optional[_str]
    Yr_Start: Optional[Union[AtomicIntInput, _int]]
    Yr_End: Optional[Union[AtomicIntInput, _int]]
    Degree: Optional[_str]
    Branch: Optional[_str]
    Electives: Optional[_str]
    Interests: Optional[_str]
    mentor: 'MentorUpdateOneWithoutRelationsInput'
    projects: 'StudentProjectUpdateManyWithoutRelationsInput'


class StudentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    ID: Union[AtomicIntInput, _int]
    Name: Optional[_str]
    eMail: Optional[_str]
    Mobile: Optional[_str]
    College: Optional[_str]
    Yr_Start: Optional[Union[AtomicIntInput, _int]]
    Yr_End: Optional[Union[AtomicIntInput, _int]]
    Degree: Optional[_str]
    Branch: Optional[_str]
    Electives: Optional[_str]
    Interests: Optional[_str]


class StudentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['StudentCreateWithoutRelationsInput']
    connect: List['StudentWhereUniqueInput']
    set: List['StudentWhereUniqueInput']
    disconnect: List['StudentWhereUniqueInput']
    delete: List['StudentWhereUniqueInput']

    # TODO
    # update: List['StudentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['StudentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['StudentScalarWhereInput']
    # upsert: List['StudentUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['StudentCreateOrConnectWithoutRelationsInput']


class StudentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'StudentCreateWithoutRelationsInput'
    connect: 'StudentWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'StudentUpdateInput'
    # upsert: 'StudentUpsertWithoutRelationsInput'
    # connectOrCreate: 'StudentCreateOrConnectWithoutRelationsInput'


class StudentUpsertInput(TypedDict):
    create: 'StudentCreateInput'
    update: 'StudentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Student_ID_OrderByInput = TypedDict(
    '_Student_ID_OrderByInput',
    {
        'ID': 'SortOrder',
    },
    total=True
)

_Student_Name_OrderByInput = TypedDict(
    '_Student_Name_OrderByInput',
    {
        'Name': 'SortOrder',
    },
    total=True
)

_Student_eMail_OrderByInput = TypedDict(
    '_Student_eMail_OrderByInput',
    {
        'eMail': 'SortOrder',
    },
    total=True
)

_Student_Mobile_OrderByInput = TypedDict(
    '_Student_Mobile_OrderByInput',
    {
        'Mobile': 'SortOrder',
    },
    total=True
)

_Student_College_OrderByInput = TypedDict(
    '_Student_College_OrderByInput',
    {
        'College': 'SortOrder',
    },
    total=True
)

_Student_Yr_Start_OrderByInput = TypedDict(
    '_Student_Yr_Start_OrderByInput',
    {
        'Yr_Start': 'SortOrder',
    },
    total=True
)

_Student_Yr_End_OrderByInput = TypedDict(
    '_Student_Yr_End_OrderByInput',
    {
        'Yr_End': 'SortOrder',
    },
    total=True
)

_Student_Degree_OrderByInput = TypedDict(
    '_Student_Degree_OrderByInput',
    {
        'Degree': 'SortOrder',
    },
    total=True
)

_Student_Branch_OrderByInput = TypedDict(
    '_Student_Branch_OrderByInput',
    {
        'Branch': 'SortOrder',
    },
    total=True
)

_Student_Electives_OrderByInput = TypedDict(
    '_Student_Electives_OrderByInput',
    {
        'Electives': 'SortOrder',
    },
    total=True
)

_Student_Interests_OrderByInput = TypedDict(
    '_Student_Interests_OrderByInput',
    {
        'Interests': 'SortOrder',
    },
    total=True
)

_Student_MentorID_OrderByInput = TypedDict(
    '_Student_MentorID_OrderByInput',
    {
        'MentorID': 'SortOrder',
    },
    total=True
)

StudentOrderByInput = Union[
    '_Student_ID_OrderByInput',
    '_Student_Name_OrderByInput',
    '_Student_eMail_OrderByInput',
    '_Student_Mobile_OrderByInput',
    '_Student_College_OrderByInput',
    '_Student_Yr_Start_OrderByInput',
    '_Student_Yr_End_OrderByInput',
    '_Student_Degree_OrderByInput',
    '_Student_Branch_OrderByInput',
    '_Student_Electives_OrderByInput',
    '_Student_Interests_OrderByInput',
    '_Student_MentorID_OrderByInput',
]



# recursive Student types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

StudentRelationFilter = TypedDict(
    'StudentRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class StudentListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class StudentInclude(TypedDict, total=False):
    """Student relational arguments"""
    mentor: Union[bool, 'MentorArgsFromStudent']
    projects: Union[bool, 'FindManyStudentProjectArgsFromStudent']


    

class OrganizationIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    mentors: Union[bool, 'FindManyMentorArgsFromStudentRecursive1']


class OrganizationIncludeFromStudentRecursive1(TypedDict, total=False):
    """Relational arguments for Student"""
    mentors: Union[bool, 'FindManyMentorArgsFromStudentRecursive2']


class OrganizationIncludeFromStudentRecursive2(TypedDict, total=False):
    """Relational arguments for Student"""
    mentors: Union[bool, 'FindManyMentorArgsFromStudentRecursive3']


class OrganizationIncludeFromStudentRecursive3(TypedDict, total=False):
    """Relational arguments for Student"""
    mentors: Union[bool, 'FindManyMentorArgsFromStudentRecursive4']


class OrganizationIncludeFromStudentRecursive4(TypedDict, total=False):
    """Relational arguments for Student"""

    

class OrganizationArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'OrganizationIncludeFromOrganizationRecursive1'


class OrganizationArgsFromStudentRecursive1(TypedDict, total=False):
    """Arguments for Student"""
    include: 'OrganizationIncludeFromOrganizationRecursive2'


class OrganizationArgsFromStudentRecursive2(TypedDict, total=False):
    """Arguments for Student"""
    include: 'OrganizationIncludeFromOrganizationRecursive3'


class OrganizationArgsFromStudentRecursive3(TypedDict, total=False):
    """Arguments for Student"""
    include: 'OrganizationIncludeFromOrganizationRecursive4'


class OrganizationArgsFromStudentRecursive4(TypedDict, total=False):
    """Arguments for Student"""
    
    

class FindManyOrganizationArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive1'


class FindManyOrganizationArgsFromStudentRecursive1(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive2'


class FindManyOrganizationArgsFromStudentRecursive2(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive3'


class FindManyOrganizationArgsFromStudentRecursive3(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive4'


class FindManyOrganizationArgsFromStudentRecursive4(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    
    

class MentorIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    organization: Union[bool, 'OrganizationArgsFromStudentRecursive1']
    students: Union[bool, 'FindManyStudentArgsFromStudentRecursive1']


class MentorIncludeFromStudentRecursive1(TypedDict, total=False):
    """Relational arguments for Student"""
    organization: Union[bool, 'OrganizationArgsFromStudentRecursive2']
    students: Union[bool, 'FindManyStudentArgsFromStudentRecursive2']


class MentorIncludeFromStudentRecursive2(TypedDict, total=False):
    """Relational arguments for Student"""
    organization: Union[bool, 'OrganizationArgsFromStudentRecursive3']
    students: Union[bool, 'FindManyStudentArgsFromStudentRecursive3']


class MentorIncludeFromStudentRecursive3(TypedDict, total=False):
    """Relational arguments for Student"""
    organization: Union[bool, 'OrganizationArgsFromStudentRecursive4']
    students: Union[bool, 'FindManyStudentArgsFromStudentRecursive4']


class MentorIncludeFromStudentRecursive4(TypedDict, total=False):
    """Relational arguments for Student"""

    

class MentorArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'MentorIncludeFromMentorRecursive1'


class MentorArgsFromStudentRecursive1(TypedDict, total=False):
    """Arguments for Student"""
    include: 'MentorIncludeFromMentorRecursive2'


class MentorArgsFromStudentRecursive2(TypedDict, total=False):
    """Arguments for Student"""
    include: 'MentorIncludeFromMentorRecursive3'


class MentorArgsFromStudentRecursive3(TypedDict, total=False):
    """Arguments for Student"""
    include: 'MentorIncludeFromMentorRecursive4'


class MentorArgsFromStudentRecursive4(TypedDict, total=False):
    """Arguments for Student"""
    
    

class FindManyMentorArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive1'


class FindManyMentorArgsFromStudentRecursive1(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive2'


class FindManyMentorArgsFromStudentRecursive2(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive3'


class FindManyMentorArgsFromStudentRecursive3(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive4'


class FindManyMentorArgsFromStudentRecursive4(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    
    

class StudentIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    mentor: Union[bool, 'MentorArgsFromStudentRecursive1']
    projects: Union[bool, 'FindManyStudentProjectArgsFromStudentRecursive1']


class StudentIncludeFromStudentRecursive1(TypedDict, total=False):
    """Relational arguments for Student"""
    mentor: Union[bool, 'MentorArgsFromStudentRecursive2']
    projects: Union[bool, 'FindManyStudentProjectArgsFromStudentRecursive2']


class StudentIncludeFromStudentRecursive2(TypedDict, total=False):
    """Relational arguments for Student"""
    mentor: Union[bool, 'MentorArgsFromStudentRecursive3']
    projects: Union[bool, 'FindManyStudentProjectArgsFromStudentRecursive3']


class StudentIncludeFromStudentRecursive3(TypedDict, total=False):
    """Relational arguments for Student"""
    mentor: Union[bool, 'MentorArgsFromStudentRecursive4']
    projects: Union[bool, 'FindManyStudentProjectArgsFromStudentRecursive4']


class StudentIncludeFromStudentRecursive4(TypedDict, total=False):
    """Relational arguments for Student"""

    

class StudentArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'StudentIncludeFromStudentRecursive1'


class StudentArgsFromStudentRecursive1(TypedDict, total=False):
    """Arguments for Student"""
    include: 'StudentIncludeFromStudentRecursive2'


class StudentArgsFromStudentRecursive2(TypedDict, total=False):
    """Arguments for Student"""
    include: 'StudentIncludeFromStudentRecursive3'


class StudentArgsFromStudentRecursive3(TypedDict, total=False):
    """Arguments for Student"""
    include: 'StudentIncludeFromStudentRecursive4'


class StudentArgsFromStudentRecursive4(TypedDict, total=False):
    """Arguments for Student"""
    
    

class FindManyStudentArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive1'


class FindManyStudentArgsFromStudentRecursive1(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive2'


class FindManyStudentArgsFromStudentRecursive2(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive3'


class FindManyStudentArgsFromStudentRecursive3(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive4'


class FindManyStudentArgsFromStudentRecursive4(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    
    

class ProjectIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    students: Union[bool, 'FindManyStudentProjectArgsFromStudentRecursive1']


class ProjectIncludeFromStudentRecursive1(TypedDict, total=False):
    """Relational arguments for Student"""
    students: Union[bool, 'FindManyStudentProjectArgsFromStudentRecursive2']


class ProjectIncludeFromStudentRecursive2(TypedDict, total=False):
    """Relational arguments for Student"""
    students: Union[bool, 'FindManyStudentProjectArgsFromStudentRecursive3']


class ProjectIncludeFromStudentRecursive3(TypedDict, total=False):
    """Relational arguments for Student"""
    students: Union[bool, 'FindManyStudentProjectArgsFromStudentRecursive4']


class ProjectIncludeFromStudentRecursive4(TypedDict, total=False):
    """Relational arguments for Student"""

    

class ProjectArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromStudentRecursive1(TypedDict, total=False):
    """Arguments for Student"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromStudentRecursive2(TypedDict, total=False):
    """Arguments for Student"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromStudentRecursive3(TypedDict, total=False):
    """Arguments for Student"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromStudentRecursive4(TypedDict, total=False):
    """Arguments for Student"""
    
    

class FindManyProjectArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromStudentRecursive1(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromStudentRecursive2(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromStudentRecursive3(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromStudentRecursive4(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class StudentProjectIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    student: Union[bool, 'StudentArgsFromStudentRecursive1']
    project: Union[bool, 'ProjectArgsFromStudentRecursive1']


class StudentProjectIncludeFromStudentRecursive1(TypedDict, total=False):
    """Relational arguments for Student"""
    student: Union[bool, 'StudentArgsFromStudentRecursive2']
    project: Union[bool, 'ProjectArgsFromStudentRecursive2']


class StudentProjectIncludeFromStudentRecursive2(TypedDict, total=False):
    """Relational arguments for Student"""
    student: Union[bool, 'StudentArgsFromStudentRecursive3']
    project: Union[bool, 'ProjectArgsFromStudentRecursive3']


class StudentProjectIncludeFromStudentRecursive3(TypedDict, total=False):
    """Relational arguments for Student"""
    student: Union[bool, 'StudentArgsFromStudentRecursive4']
    project: Union[bool, 'ProjectArgsFromStudentRecursive4']


class StudentProjectIncludeFromStudentRecursive4(TypedDict, total=False):
    """Relational arguments for Student"""

    

class StudentProjectArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive1'


class StudentProjectArgsFromStudentRecursive1(TypedDict, total=False):
    """Arguments for Student"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive2'


class StudentProjectArgsFromStudentRecursive2(TypedDict, total=False):
    """Arguments for Student"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive3'


class StudentProjectArgsFromStudentRecursive3(TypedDict, total=False):
    """Arguments for Student"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive4'


class StudentProjectArgsFromStudentRecursive4(TypedDict, total=False):
    """Arguments for Student"""
    
    

class FindManyStudentProjectArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive1'


class FindManyStudentProjectArgsFromStudentRecursive1(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive2'


class FindManyStudentProjectArgsFromStudentRecursive2(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive3'


class FindManyStudentProjectArgsFromStudentRecursive3(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive4'


class FindManyStudentProjectArgsFromStudentRecursive4(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    


FindManyStudentArgs = FindManyStudentArgsFromStudent
FindFirstStudentArgs = FindManyStudentArgsFromStudent


    

class StudentWhereInput(TypedDict, total=False):
    """Student arguments for searching"""
    ID: Union[_int, 'types.IntFilter']
    Name: Union[None, _str, 'types.StringFilter']
    eMail: Union[None, _str, 'types.StringFilter']
    Mobile: Union[None, _str, 'types.StringFilter']
    College: Union[None, _str, 'types.StringFilter']
    Yr_Start: Union[None, _int, 'types.IntFilter']
    Yr_End: Union[None, _int, 'types.IntFilter']
    Degree: Union[None, _str, 'types.StringFilter']
    Branch: Union[None, _str, 'types.StringFilter']
    Electives: Union[None, _str, 'types.StringFilter']
    Interests: Union[None, _str, 'types.StringFilter']
    MentorID: Union[None, _int, 'types.IntFilter']
    mentor: 'MentorRelationFilter'
    projects: 'StudentProjectListRelationFilter'

    # should be noted that AND and NOT should be Union['StudentWhereInputRecursive1', List['StudentWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['StudentWhereInputRecursive1']
    OR: List['StudentWhereInputRecursive1']
    NOT: List['StudentWhereInputRecursive1']


class StudentWhereInputRecursive1(TypedDict, total=False):
    """Student arguments for searching"""
    ID: Union[_int, 'types.IntFilter']
    Name: Union[None, _str, 'types.StringFilter']
    eMail: Union[None, _str, 'types.StringFilter']
    Mobile: Union[None, _str, 'types.StringFilter']
    College: Union[None, _str, 'types.StringFilter']
    Yr_Start: Union[None, _int, 'types.IntFilter']
    Yr_End: Union[None, _int, 'types.IntFilter']
    Degree: Union[None, _str, 'types.StringFilter']
    Branch: Union[None, _str, 'types.StringFilter']
    Electives: Union[None, _str, 'types.StringFilter']
    Interests: Union[None, _str, 'types.StringFilter']
    MentorID: Union[None, _int, 'types.IntFilter']
    mentor: 'MentorRelationFilter'
    projects: 'StudentProjectListRelationFilter'

    # should be noted that AND and NOT should be Union['StudentWhereInputRecursive2', List['StudentWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['StudentWhereInputRecursive2']
    OR: List['StudentWhereInputRecursive2']
    NOT: List['StudentWhereInputRecursive2']


class StudentWhereInputRecursive2(TypedDict, total=False):
    """Student arguments for searching"""
    ID: Union[_int, 'types.IntFilter']
    Name: Union[None, _str, 'types.StringFilter']
    eMail: Union[None, _str, 'types.StringFilter']
    Mobile: Union[None, _str, 'types.StringFilter']
    College: Union[None, _str, 'types.StringFilter']
    Yr_Start: Union[None, _int, 'types.IntFilter']
    Yr_End: Union[None, _int, 'types.IntFilter']
    Degree: Union[None, _str, 'types.StringFilter']
    Branch: Union[None, _str, 'types.StringFilter']
    Electives: Union[None, _str, 'types.StringFilter']
    Interests: Union[None, _str, 'types.StringFilter']
    MentorID: Union[None, _int, 'types.IntFilter']
    mentor: 'MentorRelationFilter'
    projects: 'StudentProjectListRelationFilter'

    # should be noted that AND and NOT should be Union['StudentWhereInputRecursive3', List['StudentWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['StudentWhereInputRecursive3']
    OR: List['StudentWhereInputRecursive3']
    NOT: List['StudentWhereInputRecursive3']


class StudentWhereInputRecursive3(TypedDict, total=False):
    """Student arguments for searching"""
    ID: Union[_int, 'types.IntFilter']
    Name: Union[None, _str, 'types.StringFilter']
    eMail: Union[None, _str, 'types.StringFilter']
    Mobile: Union[None, _str, 'types.StringFilter']
    College: Union[None, _str, 'types.StringFilter']
    Yr_Start: Union[None, _int, 'types.IntFilter']
    Yr_End: Union[None, _int, 'types.IntFilter']
    Degree: Union[None, _str, 'types.StringFilter']
    Branch: Union[None, _str, 'types.StringFilter']
    Electives: Union[None, _str, 'types.StringFilter']
    Interests: Union[None, _str, 'types.StringFilter']
    MentorID: Union[None, _int, 'types.IntFilter']
    mentor: 'MentorRelationFilter'
    projects: 'StudentProjectListRelationFilter'

    # should be noted that AND and NOT should be Union['StudentWhereInputRecursive4', List['StudentWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['StudentWhereInputRecursive4']
    OR: List['StudentWhereInputRecursive4']
    NOT: List['StudentWhereInputRecursive4']


class StudentWhereInputRecursive4(TypedDict, total=False):
    """Student arguments for searching"""
    ID: Union[_int, 'types.IntFilter']
    Name: Union[None, _str, 'types.StringFilter']
    eMail: Union[None, _str, 'types.StringFilter']
    Mobile: Union[None, _str, 'types.StringFilter']
    College: Union[None, _str, 'types.StringFilter']
    Yr_Start: Union[None, _int, 'types.IntFilter']
    Yr_End: Union[None, _int, 'types.IntFilter']
    Degree: Union[None, _str, 'types.StringFilter']
    Branch: Union[None, _str, 'types.StringFilter']
    Electives: Union[None, _str, 'types.StringFilter']
    Interests: Union[None, _str, 'types.StringFilter']
    MentorID: Union[None, _int, 'types.IntFilter']
    mentor: 'MentorRelationFilter'
    projects: 'StudentProjectListRelationFilter'



# aggregate Student types


    

class StudentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Student arguments for searching"""
    ID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    eMail: Union[_str, 'types.StringWithAggregatesFilter']
    Mobile: Union[_str, 'types.StringWithAggregatesFilter']
    College: Union[_str, 'types.StringWithAggregatesFilter']
    Yr_Start: Union[_int, 'types.IntWithAggregatesFilter']
    Yr_End: Union[_int, 'types.IntWithAggregatesFilter']
    Degree: Union[_str, 'types.StringWithAggregatesFilter']
    Branch: Union[_str, 'types.StringWithAggregatesFilter']
    Electives: Union[_str, 'types.StringWithAggregatesFilter']
    Interests: Union[_str, 'types.StringWithAggregatesFilter']
    MentorID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['StudentScalarWhereWithAggregatesInputRecursive1']
    OR: List['StudentScalarWhereWithAggregatesInputRecursive1']
    NOT: List['StudentScalarWhereWithAggregatesInputRecursive1']


class StudentScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Student arguments for searching"""
    ID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    eMail: Union[_str, 'types.StringWithAggregatesFilter']
    Mobile: Union[_str, 'types.StringWithAggregatesFilter']
    College: Union[_str, 'types.StringWithAggregatesFilter']
    Yr_Start: Union[_int, 'types.IntWithAggregatesFilter']
    Yr_End: Union[_int, 'types.IntWithAggregatesFilter']
    Degree: Union[_str, 'types.StringWithAggregatesFilter']
    Branch: Union[_str, 'types.StringWithAggregatesFilter']
    Electives: Union[_str, 'types.StringWithAggregatesFilter']
    Interests: Union[_str, 'types.StringWithAggregatesFilter']
    MentorID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['StudentScalarWhereWithAggregatesInputRecursive2']
    OR: List['StudentScalarWhereWithAggregatesInputRecursive2']
    NOT: List['StudentScalarWhereWithAggregatesInputRecursive2']


class StudentScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Student arguments for searching"""
    ID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    eMail: Union[_str, 'types.StringWithAggregatesFilter']
    Mobile: Union[_str, 'types.StringWithAggregatesFilter']
    College: Union[_str, 'types.StringWithAggregatesFilter']
    Yr_Start: Union[_int, 'types.IntWithAggregatesFilter']
    Yr_End: Union[_int, 'types.IntWithAggregatesFilter']
    Degree: Union[_str, 'types.StringWithAggregatesFilter']
    Branch: Union[_str, 'types.StringWithAggregatesFilter']
    Electives: Union[_str, 'types.StringWithAggregatesFilter']
    Interests: Union[_str, 'types.StringWithAggregatesFilter']
    MentorID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['StudentScalarWhereWithAggregatesInputRecursive3']
    OR: List['StudentScalarWhereWithAggregatesInputRecursive3']
    NOT: List['StudentScalarWhereWithAggregatesInputRecursive3']


class StudentScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Student arguments for searching"""
    ID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    eMail: Union[_str, 'types.StringWithAggregatesFilter']
    Mobile: Union[_str, 'types.StringWithAggregatesFilter']
    College: Union[_str, 'types.StringWithAggregatesFilter']
    Yr_Start: Union[_int, 'types.IntWithAggregatesFilter']
    Yr_End: Union[_int, 'types.IntWithAggregatesFilter']
    Degree: Union[_str, 'types.StringWithAggregatesFilter']
    Branch: Union[_str, 'types.StringWithAggregatesFilter']
    Electives: Union[_str, 'types.StringWithAggregatesFilter']
    Interests: Union[_str, 'types.StringWithAggregatesFilter']
    MentorID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['StudentScalarWhereWithAggregatesInputRecursive4']
    OR: List['StudentScalarWhereWithAggregatesInputRecursive4']
    NOT: List['StudentScalarWhereWithAggregatesInputRecursive4']


class StudentScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Student arguments for searching"""
    ID: Union[_int, 'types.IntWithAggregatesFilter']
    Name: Union[_str, 'types.StringWithAggregatesFilter']
    eMail: Union[_str, 'types.StringWithAggregatesFilter']
    Mobile: Union[_str, 'types.StringWithAggregatesFilter']
    College: Union[_str, 'types.StringWithAggregatesFilter']
    Yr_Start: Union[_int, 'types.IntWithAggregatesFilter']
    Yr_End: Union[_int, 'types.IntWithAggregatesFilter']
    Degree: Union[_str, 'types.StringWithAggregatesFilter']
    Branch: Union[_str, 'types.StringWithAggregatesFilter']
    Electives: Union[_str, 'types.StringWithAggregatesFilter']
    Interests: Union[_str, 'types.StringWithAggregatesFilter']
    MentorID: Union[_int, 'types.IntWithAggregatesFilter']



class StudentGroupByOutput(TypedDict, total=False):
    ID: _int
    Name: _str
    eMail: _str
    Mobile: _str
    College: _str
    Yr_Start: _int
    Yr_End: _int
    Degree: _str
    Branch: _str
    Electives: _str
    Interests: _str
    MentorID: _int
    _sum: 'StudentSumAggregateOutput'
    _avg: 'StudentAvgAggregateOutput'
    _min: 'StudentMinAggregateOutput'
    _max: 'StudentMaxAggregateOutput'
    _count: 'StudentCountAggregateOutput'


class StudentAvgAggregateOutput(TypedDict, total=False):
    """Student output for aggregating averages"""
    ID: float
    Yr_Start: float
    Yr_End: float
    MentorID: float


class StudentSumAggregateOutput(TypedDict, total=False):
    """Student output for aggregating sums"""
    ID: _int
    Yr_Start: _int
    Yr_End: _int
    MentorID: _int


class StudentScalarAggregateOutput(TypedDict, total=False):
    """Student output including scalar fields"""
    ID: _int
    Name: _str
    eMail: _str
    Mobile: _str
    College: _str
    Yr_Start: _int
    Yr_End: _int
    Degree: _str
    Branch: _str
    Electives: _str
    Interests: _str
    MentorID: _int


StudentMinAggregateOutput = StudentScalarAggregateOutput
StudentMaxAggregateOutput = StudentScalarAggregateOutput


class StudentMaxAggregateInput(TypedDict, total=False):
    """Student input for aggregating by max"""
    ID: bool
    Name: bool
    eMail: bool
    Mobile: bool
    College: bool
    Yr_Start: bool
    Yr_End: bool
    Degree: bool
    Branch: bool
    Electives: bool
    Interests: bool
    MentorID: bool


class StudentMinAggregateInput(TypedDict, total=False):
    """Student input for aggregating by min"""
    ID: bool
    Name: bool
    eMail: bool
    Mobile: bool
    College: bool
    Yr_Start: bool
    Yr_End: bool
    Degree: bool
    Branch: bool
    Electives: bool
    Interests: bool
    MentorID: bool


class StudentNumberAggregateInput(TypedDict, total=False):
    """Student input for aggregating numbers"""
    ID: bool
    Yr_Start: bool
    Yr_End: bool
    MentorID: bool


StudentAvgAggregateInput = StudentNumberAggregateInput
StudentSumAggregateInput = StudentNumberAggregateInput


StudentCountAggregateInput = TypedDict(
    'StudentCountAggregateInput',
    {
        'ID': bool,
        'Name': bool,
        'eMail': bool,
        'Mobile': bool,
        'College': bool,
        'Yr_Start': bool,
        'Yr_End': bool,
        'Degree': bool,
        'Branch': bool,
        'Electives': bool,
        'Interests': bool,
        'MentorID': bool,
        '_all': bool,
    },
    total=False,
)

StudentCountAggregateOutput = TypedDict(
    'StudentCountAggregateOutput',
    {
        'ID': int,
        'Name': int,
        'eMail': int,
        'Mobile': int,
        'College': int,
        'Yr_Start': int,
        'Yr_End': int,
        'Degree': int,
        'Branch': int,
        'Electives': int,
        'Interests': int,
        'MentorID': int,
        '_all': int,
    },
    total=False,
)


StudentKeys = Literal[
    'ID',
    'Name',
    'eMail',
    'Mobile',
    'College',
    'Yr_Start',
    'Yr_End',
    'Degree',
    'Branch',
    'Electives',
    'Interests',
    'MentorID',
    'mentor',
    'projects',
]
StudentScalarFieldKeys = Literal[
    'ID',
    'Name',
    'eMail',
    'Mobile',
    'College',
    'Yr_Start',
    'Yr_End',
    'Degree',
    'Branch',
    'Electives',
    'Interests',
    'MentorID',
]
StudentScalarFieldKeysT = TypeVar('StudentScalarFieldKeysT', bound=StudentScalarFieldKeys)

StudentRelationalFieldKeys = Literal[
        'mentor',
        'projects',
    ]

# Project types

class ProjectOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Project create method"""
    Title: Optional[_str]
    Description: Optional[_str]
    Approach: Optional[_str]
    Skills: Optional[_str]
    HW_Needed: Optional[_str]
    Milestones: Optional[_str]
    students: 'StudentProjectCreateManyNestedWithoutRelationsInput'


class ProjectCreateInput(ProjectOptionalCreateInput):
    """Required arguments to the Project create method"""
    ProjectID: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ProjectOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Project create method, without relations"""
    Title: Optional[_str]
    Description: Optional[_str]
    Approach: Optional[_str]
    Skills: Optional[_str]
    HW_Needed: Optional[_str]
    Milestones: Optional[_str]


class ProjectCreateWithoutRelationsInput(ProjectOptionalCreateWithoutRelationsInput):
    """Required arguments to the Project create method, without relations"""
    ProjectID: _int


class ProjectCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ProjectCreateWithoutRelationsInput'
    connect: 'ProjectWhereUniqueInput'


class ProjectCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ProjectCreateWithoutRelationsInput', List['ProjectCreateWithoutRelationsInput']]
    connect: Union['ProjectWhereUniqueInput', List['ProjectWhereUniqueInput']]


_ProjectWhereUnique_ProjectID_Input = TypedDict(
    '_ProjectWhereUnique_ProjectID_Input',
    {
        'ProjectID': '_int',
    },
    total=True
)

ProjectWhereUniqueInput = _ProjectWhereUnique_ProjectID_Input


class ProjectUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    ProjectID: Union[AtomicIntInput, _int]
    Title: Optional[_str]
    Description: Optional[_str]
    Approach: Optional[_str]
    Skills: Optional[_str]
    HW_Needed: Optional[_str]
    Milestones: Optional[_str]
    students: 'StudentProjectUpdateManyWithoutRelationsInput'


class ProjectUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    ProjectID: Union[AtomicIntInput, _int]
    Title: Optional[_str]
    Description: Optional[_str]
    Approach: Optional[_str]
    Skills: Optional[_str]
    HW_Needed: Optional[_str]
    Milestones: Optional[_str]


class ProjectUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ProjectCreateWithoutRelationsInput']
    connect: List['ProjectWhereUniqueInput']
    set: List['ProjectWhereUniqueInput']
    disconnect: List['ProjectWhereUniqueInput']
    delete: List['ProjectWhereUniqueInput']

    # TODO
    # update: List['ProjectUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ProjectUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ProjectScalarWhereInput']
    # upsert: List['ProjectUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ProjectCreateOrConnectWithoutRelationsInput']


class ProjectUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ProjectCreateWithoutRelationsInput'
    connect: 'ProjectWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ProjectUpdateInput'
    # upsert: 'ProjectUpsertWithoutRelationsInput'
    # connectOrCreate: 'ProjectCreateOrConnectWithoutRelationsInput'


class ProjectUpsertInput(TypedDict):
    create: 'ProjectCreateInput'
    update: 'ProjectUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Project_ProjectID_OrderByInput = TypedDict(
    '_Project_ProjectID_OrderByInput',
    {
        'ProjectID': 'SortOrder',
    },
    total=True
)

_Project_Title_OrderByInput = TypedDict(
    '_Project_Title_OrderByInput',
    {
        'Title': 'SortOrder',
    },
    total=True
)

_Project_Description_OrderByInput = TypedDict(
    '_Project_Description_OrderByInput',
    {
        'Description': 'SortOrder',
    },
    total=True
)

_Project_Approach_OrderByInput = TypedDict(
    '_Project_Approach_OrderByInput',
    {
        'Approach': 'SortOrder',
    },
    total=True
)

_Project_Skills_OrderByInput = TypedDict(
    '_Project_Skills_OrderByInput',
    {
        'Skills': 'SortOrder',
    },
    total=True
)

_Project_HW_Needed_OrderByInput = TypedDict(
    '_Project_HW_Needed_OrderByInput',
    {
        'HW_Needed': 'SortOrder',
    },
    total=True
)

_Project_Milestones_OrderByInput = TypedDict(
    '_Project_Milestones_OrderByInput',
    {
        'Milestones': 'SortOrder',
    },
    total=True
)

ProjectOrderByInput = Union[
    '_Project_ProjectID_OrderByInput',
    '_Project_Title_OrderByInput',
    '_Project_Description_OrderByInput',
    '_Project_Approach_OrderByInput',
    '_Project_Skills_OrderByInput',
    '_Project_HW_Needed_OrderByInput',
    '_Project_Milestones_OrderByInput',
]



# recursive Project types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ProjectRelationFilter = TypedDict(
    'ProjectRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ProjectListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ProjectInclude(TypedDict, total=False):
    """Project relational arguments"""
    students: Union[bool, 'FindManyStudentProjectArgsFromProject']


    

class OrganizationIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    mentors: Union[bool, 'FindManyMentorArgsFromProjectRecursive1']


class OrganizationIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    mentors: Union[bool, 'FindManyMentorArgsFromProjectRecursive2']


class OrganizationIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    mentors: Union[bool, 'FindManyMentorArgsFromProjectRecursive3']


class OrganizationIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    mentors: Union[bool, 'FindManyMentorArgsFromProjectRecursive4']


class OrganizationIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class OrganizationArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'OrganizationIncludeFromOrganizationRecursive1'


class OrganizationArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'OrganizationIncludeFromOrganizationRecursive2'


class OrganizationArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'OrganizationIncludeFromOrganizationRecursive3'


class OrganizationArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'OrganizationIncludeFromOrganizationRecursive4'


class OrganizationArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyOrganizationArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive1'


class FindManyOrganizationArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive2'


class FindManyOrganizationArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive3'


class FindManyOrganizationArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive4'


class FindManyOrganizationArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    
    

class MentorIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    organization: Union[bool, 'OrganizationArgsFromProjectRecursive1']
    students: Union[bool, 'FindManyStudentArgsFromProjectRecursive1']


class MentorIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    organization: Union[bool, 'OrganizationArgsFromProjectRecursive2']
    students: Union[bool, 'FindManyStudentArgsFromProjectRecursive2']


class MentorIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    organization: Union[bool, 'OrganizationArgsFromProjectRecursive3']
    students: Union[bool, 'FindManyStudentArgsFromProjectRecursive3']


class MentorIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    organization: Union[bool, 'OrganizationArgsFromProjectRecursive4']
    students: Union[bool, 'FindManyStudentArgsFromProjectRecursive4']


class MentorIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class MentorArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'MentorIncludeFromMentorRecursive1'


class MentorArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'MentorIncludeFromMentorRecursive2'


class MentorArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'MentorIncludeFromMentorRecursive3'


class MentorArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'MentorIncludeFromMentorRecursive4'


class MentorArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyMentorArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive1'


class FindManyMentorArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive2'


class FindManyMentorArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive3'


class FindManyMentorArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive4'


class FindManyMentorArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    
    

class StudentIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    mentor: Union[bool, 'MentorArgsFromProjectRecursive1']
    projects: Union[bool, 'FindManyStudentProjectArgsFromProjectRecursive1']


class StudentIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    mentor: Union[bool, 'MentorArgsFromProjectRecursive2']
    projects: Union[bool, 'FindManyStudentProjectArgsFromProjectRecursive2']


class StudentIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    mentor: Union[bool, 'MentorArgsFromProjectRecursive3']
    projects: Union[bool, 'FindManyStudentProjectArgsFromProjectRecursive3']


class StudentIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    mentor: Union[bool, 'MentorArgsFromProjectRecursive4']
    projects: Union[bool, 'FindManyStudentProjectArgsFromProjectRecursive4']


class StudentIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class StudentArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'StudentIncludeFromStudentRecursive1'


class StudentArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'StudentIncludeFromStudentRecursive2'


class StudentArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'StudentIncludeFromStudentRecursive3'


class StudentArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'StudentIncludeFromStudentRecursive4'


class StudentArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyStudentArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive1'


class FindManyStudentArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive2'


class FindManyStudentArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive3'


class FindManyStudentArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive4'


class FindManyStudentArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    
    

class ProjectIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    students: Union[bool, 'FindManyStudentProjectArgsFromProjectRecursive1']


class ProjectIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    students: Union[bool, 'FindManyStudentProjectArgsFromProjectRecursive2']


class ProjectIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    students: Union[bool, 'FindManyStudentProjectArgsFromProjectRecursive3']


class ProjectIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    students: Union[bool, 'FindManyStudentProjectArgsFromProjectRecursive4']


class ProjectIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class ProjectArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyProjectArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class StudentProjectIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    student: Union[bool, 'StudentArgsFromProjectRecursive1']
    project: Union[bool, 'ProjectArgsFromProjectRecursive1']


class StudentProjectIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    student: Union[bool, 'StudentArgsFromProjectRecursive2']
    project: Union[bool, 'ProjectArgsFromProjectRecursive2']


class StudentProjectIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    student: Union[bool, 'StudentArgsFromProjectRecursive3']
    project: Union[bool, 'ProjectArgsFromProjectRecursive3']


class StudentProjectIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    student: Union[bool, 'StudentArgsFromProjectRecursive4']
    project: Union[bool, 'ProjectArgsFromProjectRecursive4']


class StudentProjectIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class StudentProjectArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive1'


class StudentProjectArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive2'


class StudentProjectArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive3'


class StudentProjectArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive4'


class StudentProjectArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyStudentProjectArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive1'


class FindManyStudentProjectArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive2'


class FindManyStudentProjectArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive3'


class FindManyStudentProjectArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive4'


class FindManyStudentProjectArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    


FindManyProjectArgs = FindManyProjectArgsFromProject
FindFirstProjectArgs = FindManyProjectArgsFromProject


    

class ProjectWhereInput(TypedDict, total=False):
    """Project arguments for searching"""
    ProjectID: Union[_int, 'types.IntFilter']
    Title: Union[None, _str, 'types.StringFilter']
    Description: Union[None, _str, 'types.StringFilter']
    Approach: Union[None, _str, 'types.StringFilter']
    Skills: Union[None, _str, 'types.StringFilter']
    HW_Needed: Union[None, _str, 'types.StringFilter']
    Milestones: Union[None, _str, 'types.StringFilter']
    students: 'StudentProjectListRelationFilter'

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive1', List['ProjectWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive1']
    OR: List['ProjectWhereInputRecursive1']
    NOT: List['ProjectWhereInputRecursive1']


class ProjectWhereInputRecursive1(TypedDict, total=False):
    """Project arguments for searching"""
    ProjectID: Union[_int, 'types.IntFilter']
    Title: Union[None, _str, 'types.StringFilter']
    Description: Union[None, _str, 'types.StringFilter']
    Approach: Union[None, _str, 'types.StringFilter']
    Skills: Union[None, _str, 'types.StringFilter']
    HW_Needed: Union[None, _str, 'types.StringFilter']
    Milestones: Union[None, _str, 'types.StringFilter']
    students: 'StudentProjectListRelationFilter'

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive2', List['ProjectWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive2']
    OR: List['ProjectWhereInputRecursive2']
    NOT: List['ProjectWhereInputRecursive2']


class ProjectWhereInputRecursive2(TypedDict, total=False):
    """Project arguments for searching"""
    ProjectID: Union[_int, 'types.IntFilter']
    Title: Union[None, _str, 'types.StringFilter']
    Description: Union[None, _str, 'types.StringFilter']
    Approach: Union[None, _str, 'types.StringFilter']
    Skills: Union[None, _str, 'types.StringFilter']
    HW_Needed: Union[None, _str, 'types.StringFilter']
    Milestones: Union[None, _str, 'types.StringFilter']
    students: 'StudentProjectListRelationFilter'

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive3', List['ProjectWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive3']
    OR: List['ProjectWhereInputRecursive3']
    NOT: List['ProjectWhereInputRecursive3']


class ProjectWhereInputRecursive3(TypedDict, total=False):
    """Project arguments for searching"""
    ProjectID: Union[_int, 'types.IntFilter']
    Title: Union[None, _str, 'types.StringFilter']
    Description: Union[None, _str, 'types.StringFilter']
    Approach: Union[None, _str, 'types.StringFilter']
    Skills: Union[None, _str, 'types.StringFilter']
    HW_Needed: Union[None, _str, 'types.StringFilter']
    Milestones: Union[None, _str, 'types.StringFilter']
    students: 'StudentProjectListRelationFilter'

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive4', List['ProjectWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive4']
    OR: List['ProjectWhereInputRecursive4']
    NOT: List['ProjectWhereInputRecursive4']


class ProjectWhereInputRecursive4(TypedDict, total=False):
    """Project arguments for searching"""
    ProjectID: Union[_int, 'types.IntFilter']
    Title: Union[None, _str, 'types.StringFilter']
    Description: Union[None, _str, 'types.StringFilter']
    Approach: Union[None, _str, 'types.StringFilter']
    Skills: Union[None, _str, 'types.StringFilter']
    HW_Needed: Union[None, _str, 'types.StringFilter']
    Milestones: Union[None, _str, 'types.StringFilter']
    students: 'StudentProjectListRelationFilter'



# aggregate Project types


    

class ProjectScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Project arguments for searching"""
    ProjectID: Union[_int, 'types.IntWithAggregatesFilter']
    Title: Union[_str, 'types.StringWithAggregatesFilter']
    Description: Union[_str, 'types.StringWithAggregatesFilter']
    Approach: Union[_str, 'types.StringWithAggregatesFilter']
    Skills: Union[_str, 'types.StringWithAggregatesFilter']
    HW_Needed: Union[_str, 'types.StringWithAggregatesFilter']
    Milestones: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive1']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive1']


class ProjectScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Project arguments for searching"""
    ProjectID: Union[_int, 'types.IntWithAggregatesFilter']
    Title: Union[_str, 'types.StringWithAggregatesFilter']
    Description: Union[_str, 'types.StringWithAggregatesFilter']
    Approach: Union[_str, 'types.StringWithAggregatesFilter']
    Skills: Union[_str, 'types.StringWithAggregatesFilter']
    HW_Needed: Union[_str, 'types.StringWithAggregatesFilter']
    Milestones: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive2']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive2']


class ProjectScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Project arguments for searching"""
    ProjectID: Union[_int, 'types.IntWithAggregatesFilter']
    Title: Union[_str, 'types.StringWithAggregatesFilter']
    Description: Union[_str, 'types.StringWithAggregatesFilter']
    Approach: Union[_str, 'types.StringWithAggregatesFilter']
    Skills: Union[_str, 'types.StringWithAggregatesFilter']
    HW_Needed: Union[_str, 'types.StringWithAggregatesFilter']
    Milestones: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive3']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive3']


class ProjectScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Project arguments for searching"""
    ProjectID: Union[_int, 'types.IntWithAggregatesFilter']
    Title: Union[_str, 'types.StringWithAggregatesFilter']
    Description: Union[_str, 'types.StringWithAggregatesFilter']
    Approach: Union[_str, 'types.StringWithAggregatesFilter']
    Skills: Union[_str, 'types.StringWithAggregatesFilter']
    HW_Needed: Union[_str, 'types.StringWithAggregatesFilter']
    Milestones: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive4']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive4']


class ProjectScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Project arguments for searching"""
    ProjectID: Union[_int, 'types.IntWithAggregatesFilter']
    Title: Union[_str, 'types.StringWithAggregatesFilter']
    Description: Union[_str, 'types.StringWithAggregatesFilter']
    Approach: Union[_str, 'types.StringWithAggregatesFilter']
    Skills: Union[_str, 'types.StringWithAggregatesFilter']
    HW_Needed: Union[_str, 'types.StringWithAggregatesFilter']
    Milestones: Union[_str, 'types.StringWithAggregatesFilter']



class ProjectGroupByOutput(TypedDict, total=False):
    ProjectID: _int
    Title: _str
    Description: _str
    Approach: _str
    Skills: _str
    HW_Needed: _str
    Milestones: _str
    _sum: 'ProjectSumAggregateOutput'
    _avg: 'ProjectAvgAggregateOutput'
    _min: 'ProjectMinAggregateOutput'
    _max: 'ProjectMaxAggregateOutput'
    _count: 'ProjectCountAggregateOutput'


class ProjectAvgAggregateOutput(TypedDict, total=False):
    """Project output for aggregating averages"""
    ProjectID: float


class ProjectSumAggregateOutput(TypedDict, total=False):
    """Project output for aggregating sums"""
    ProjectID: _int


class ProjectScalarAggregateOutput(TypedDict, total=False):
    """Project output including scalar fields"""
    ProjectID: _int
    Title: _str
    Description: _str
    Approach: _str
    Skills: _str
    HW_Needed: _str
    Milestones: _str


ProjectMinAggregateOutput = ProjectScalarAggregateOutput
ProjectMaxAggregateOutput = ProjectScalarAggregateOutput


class ProjectMaxAggregateInput(TypedDict, total=False):
    """Project input for aggregating by max"""
    ProjectID: bool
    Title: bool
    Description: bool
    Approach: bool
    Skills: bool
    HW_Needed: bool
    Milestones: bool


class ProjectMinAggregateInput(TypedDict, total=False):
    """Project input for aggregating by min"""
    ProjectID: bool
    Title: bool
    Description: bool
    Approach: bool
    Skills: bool
    HW_Needed: bool
    Milestones: bool


class ProjectNumberAggregateInput(TypedDict, total=False):
    """Project input for aggregating numbers"""
    ProjectID: bool


ProjectAvgAggregateInput = ProjectNumberAggregateInput
ProjectSumAggregateInput = ProjectNumberAggregateInput


ProjectCountAggregateInput = TypedDict(
    'ProjectCountAggregateInput',
    {
        'ProjectID': bool,
        'Title': bool,
        'Description': bool,
        'Approach': bool,
        'Skills': bool,
        'HW_Needed': bool,
        'Milestones': bool,
        '_all': bool,
    },
    total=False,
)

ProjectCountAggregateOutput = TypedDict(
    'ProjectCountAggregateOutput',
    {
        'ProjectID': int,
        'Title': int,
        'Description': int,
        'Approach': int,
        'Skills': int,
        'HW_Needed': int,
        'Milestones': int,
        '_all': int,
    },
    total=False,
)


ProjectKeys = Literal[
    'ProjectID',
    'Title',
    'Description',
    'Approach',
    'Skills',
    'HW_Needed',
    'Milestones',
    'students',
]
ProjectScalarFieldKeys = Literal[
    'ProjectID',
    'Title',
    'Description',
    'Approach',
    'Skills',
    'HW_Needed',
    'Milestones',
]
ProjectScalarFieldKeysT = TypeVar('ProjectScalarFieldKeysT', bound=ProjectScalarFieldKeys)

ProjectRelationalFieldKeys = Literal[
        'students',
    ]

# StudentProject types

class StudentProjectOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the StudentProject create method"""
    StudentID: _int
    ProjectID: _int
    student: 'StudentCreateNestedWithoutRelationsInput'
    project: 'ProjectCreateNestedWithoutRelationsInput'


class StudentProjectCreateInput(StudentProjectOptionalCreateInput):
    """Required arguments to the StudentProject create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class StudentProjectOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the StudentProject create method, without relations"""
    StudentID: _int
    ProjectID: _int


class StudentProjectCreateWithoutRelationsInput(StudentProjectOptionalCreateWithoutRelationsInput):
    """Required arguments to the StudentProject create method, without relations"""


class StudentProjectCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'StudentProjectCreateWithoutRelationsInput'
    connect: 'StudentProjectWhereUniqueInput'


class StudentProjectCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['StudentProjectCreateWithoutRelationsInput', List['StudentProjectCreateWithoutRelationsInput']]
    connect: Union['StudentProjectWhereUniqueInput', List['StudentProjectWhereUniqueInput']]


_StudentProjectCompoundPrimaryKeyInner = TypedDict(
    '_StudentProjectCompoundPrimaryKeyInner',
    {
        'StudentID': '_int',
        'ProjectID': '_int',
    },
    total=True
)

_StudentProjectCompoundPrimaryKey = TypedDict(
    '_StudentProjectCompoundPrimaryKey',
    {
        'StudentID_ProjectID': '_StudentProjectCompoundPrimaryKeyInner',
    },
    total=True
)

StudentProjectWhereUniqueInput = _StudentProjectCompoundPrimaryKey


class StudentProjectUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    student: 'StudentUpdateOneWithoutRelationsInput'
    project: 'ProjectUpdateOneWithoutRelationsInput'


class StudentProjectUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""


class StudentProjectUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['StudentProjectCreateWithoutRelationsInput']
    connect: List['StudentProjectWhereUniqueInput']
    set: List['StudentProjectWhereUniqueInput']
    disconnect: List['StudentProjectWhereUniqueInput']
    delete: List['StudentProjectWhereUniqueInput']

    # TODO
    # update: List['StudentProjectUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['StudentProjectUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['StudentProjectScalarWhereInput']
    # upsert: List['StudentProjectUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['StudentProjectCreateOrConnectWithoutRelationsInput']


class StudentProjectUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'StudentProjectCreateWithoutRelationsInput'
    connect: 'StudentProjectWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'StudentProjectUpdateInput'
    # upsert: 'StudentProjectUpsertWithoutRelationsInput'
    # connectOrCreate: 'StudentProjectCreateOrConnectWithoutRelationsInput'


class StudentProjectUpsertInput(TypedDict):
    create: 'StudentProjectCreateInput'
    update: 'StudentProjectUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_StudentProject_StudentID_OrderByInput = TypedDict(
    '_StudentProject_StudentID_OrderByInput',
    {
        'StudentID': 'SortOrder',
    },
    total=True
)

_StudentProject_ProjectID_OrderByInput = TypedDict(
    '_StudentProject_ProjectID_OrderByInput',
    {
        'ProjectID': 'SortOrder',
    },
    total=True
)

StudentProjectOrderByInput = Union[
    '_StudentProject_StudentID_OrderByInput',
    '_StudentProject_ProjectID_OrderByInput',
]



# recursive StudentProject types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

StudentProjectRelationFilter = TypedDict(
    'StudentProjectRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class StudentProjectListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class StudentProjectInclude(TypedDict, total=False):
    """StudentProject relational arguments"""
    student: Union[bool, 'StudentArgsFromStudentProject']
    project: Union[bool, 'ProjectArgsFromStudentProject']


    

class OrganizationIncludeFromStudentProject(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    mentors: Union[bool, 'FindManyMentorArgsFromStudentProjectRecursive1']


class OrganizationIncludeFromStudentProjectRecursive1(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    mentors: Union[bool, 'FindManyMentorArgsFromStudentProjectRecursive2']


class OrganizationIncludeFromStudentProjectRecursive2(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    mentors: Union[bool, 'FindManyMentorArgsFromStudentProjectRecursive3']


class OrganizationIncludeFromStudentProjectRecursive3(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    mentors: Union[bool, 'FindManyMentorArgsFromStudentProjectRecursive4']


class OrganizationIncludeFromStudentProjectRecursive4(TypedDict, total=False):
    """Relational arguments for StudentProject"""

    

class OrganizationArgsFromStudentProject(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'OrganizationIncludeFromOrganizationRecursive1'


class OrganizationArgsFromStudentProjectRecursive1(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'OrganizationIncludeFromOrganizationRecursive2'


class OrganizationArgsFromStudentProjectRecursive2(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'OrganizationIncludeFromOrganizationRecursive3'


class OrganizationArgsFromStudentProjectRecursive3(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'OrganizationIncludeFromOrganizationRecursive4'


class OrganizationArgsFromStudentProjectRecursive4(TypedDict, total=False):
    """Arguments for StudentProject"""
    
    

class FindManyOrganizationArgsFromStudentProject(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive1'


class FindManyOrganizationArgsFromStudentProjectRecursive1(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive2'


class FindManyOrganizationArgsFromStudentProjectRecursive2(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive3'


class FindManyOrganizationArgsFromStudentProjectRecursive3(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    include: 'OrganizationIncludeFromOrganizationRecursive4'


class FindManyOrganizationArgsFromStudentProjectRecursive4(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['OrganizationOrderByInput', List['OrganizationOrderByInput']]
    where: 'OrganizationWhereInput'
    cursor: 'OrganizationWhereUniqueInput'
    distinct: List['OrganizationScalarFieldKeys']
    
    

class MentorIncludeFromStudentProject(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    organization: Union[bool, 'OrganizationArgsFromStudentProjectRecursive1']
    students: Union[bool, 'FindManyStudentArgsFromStudentProjectRecursive1']


class MentorIncludeFromStudentProjectRecursive1(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    organization: Union[bool, 'OrganizationArgsFromStudentProjectRecursive2']
    students: Union[bool, 'FindManyStudentArgsFromStudentProjectRecursive2']


class MentorIncludeFromStudentProjectRecursive2(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    organization: Union[bool, 'OrganizationArgsFromStudentProjectRecursive3']
    students: Union[bool, 'FindManyStudentArgsFromStudentProjectRecursive3']


class MentorIncludeFromStudentProjectRecursive3(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    organization: Union[bool, 'OrganizationArgsFromStudentProjectRecursive4']
    students: Union[bool, 'FindManyStudentArgsFromStudentProjectRecursive4']


class MentorIncludeFromStudentProjectRecursive4(TypedDict, total=False):
    """Relational arguments for StudentProject"""

    

class MentorArgsFromStudentProject(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'MentorIncludeFromMentorRecursive1'


class MentorArgsFromStudentProjectRecursive1(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'MentorIncludeFromMentorRecursive2'


class MentorArgsFromStudentProjectRecursive2(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'MentorIncludeFromMentorRecursive3'


class MentorArgsFromStudentProjectRecursive3(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'MentorIncludeFromMentorRecursive4'


class MentorArgsFromStudentProjectRecursive4(TypedDict, total=False):
    """Arguments for StudentProject"""
    
    

class FindManyMentorArgsFromStudentProject(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive1'


class FindManyMentorArgsFromStudentProjectRecursive1(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive2'


class FindManyMentorArgsFromStudentProjectRecursive2(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive3'


class FindManyMentorArgsFromStudentProjectRecursive3(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    include: 'MentorIncludeFromMentorRecursive4'


class FindManyMentorArgsFromStudentProjectRecursive4(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['MentorOrderByInput', List['MentorOrderByInput']]
    where: 'MentorWhereInput'
    cursor: 'MentorWhereUniqueInput'
    distinct: List['MentorScalarFieldKeys']
    
    

class StudentIncludeFromStudentProject(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    mentor: Union[bool, 'MentorArgsFromStudentProjectRecursive1']
    projects: Union[bool, 'FindManyStudentProjectArgsFromStudentProjectRecursive1']


class StudentIncludeFromStudentProjectRecursive1(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    mentor: Union[bool, 'MentorArgsFromStudentProjectRecursive2']
    projects: Union[bool, 'FindManyStudentProjectArgsFromStudentProjectRecursive2']


class StudentIncludeFromStudentProjectRecursive2(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    mentor: Union[bool, 'MentorArgsFromStudentProjectRecursive3']
    projects: Union[bool, 'FindManyStudentProjectArgsFromStudentProjectRecursive3']


class StudentIncludeFromStudentProjectRecursive3(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    mentor: Union[bool, 'MentorArgsFromStudentProjectRecursive4']
    projects: Union[bool, 'FindManyStudentProjectArgsFromStudentProjectRecursive4']


class StudentIncludeFromStudentProjectRecursive4(TypedDict, total=False):
    """Relational arguments for StudentProject"""

    

class StudentArgsFromStudentProject(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'StudentIncludeFromStudentRecursive1'


class StudentArgsFromStudentProjectRecursive1(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'StudentIncludeFromStudentRecursive2'


class StudentArgsFromStudentProjectRecursive2(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'StudentIncludeFromStudentRecursive3'


class StudentArgsFromStudentProjectRecursive3(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'StudentIncludeFromStudentRecursive4'


class StudentArgsFromStudentProjectRecursive4(TypedDict, total=False):
    """Arguments for StudentProject"""
    
    

class FindManyStudentArgsFromStudentProject(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive1'


class FindManyStudentArgsFromStudentProjectRecursive1(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive2'


class FindManyStudentArgsFromStudentProjectRecursive2(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive3'


class FindManyStudentArgsFromStudentProjectRecursive3(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudentRecursive4'


class FindManyStudentArgsFromStudentProjectRecursive4(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    
    

class ProjectIncludeFromStudentProject(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    students: Union[bool, 'FindManyStudentProjectArgsFromStudentProjectRecursive1']


class ProjectIncludeFromStudentProjectRecursive1(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    students: Union[bool, 'FindManyStudentProjectArgsFromStudentProjectRecursive2']


class ProjectIncludeFromStudentProjectRecursive2(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    students: Union[bool, 'FindManyStudentProjectArgsFromStudentProjectRecursive3']


class ProjectIncludeFromStudentProjectRecursive3(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    students: Union[bool, 'FindManyStudentProjectArgsFromStudentProjectRecursive4']


class ProjectIncludeFromStudentProjectRecursive4(TypedDict, total=False):
    """Relational arguments for StudentProject"""

    

class ProjectArgsFromStudentProject(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromStudentProjectRecursive1(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromStudentProjectRecursive2(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromStudentProjectRecursive3(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromStudentProjectRecursive4(TypedDict, total=False):
    """Arguments for StudentProject"""
    
    

class FindManyProjectArgsFromStudentProject(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromStudentProjectRecursive1(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromStudentProjectRecursive2(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromStudentProjectRecursive3(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromStudentProjectRecursive4(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class StudentProjectIncludeFromStudentProject(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    student: Union[bool, 'StudentArgsFromStudentProjectRecursive1']
    project: Union[bool, 'ProjectArgsFromStudentProjectRecursive1']


class StudentProjectIncludeFromStudentProjectRecursive1(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    student: Union[bool, 'StudentArgsFromStudentProjectRecursive2']
    project: Union[bool, 'ProjectArgsFromStudentProjectRecursive2']


class StudentProjectIncludeFromStudentProjectRecursive2(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    student: Union[bool, 'StudentArgsFromStudentProjectRecursive3']
    project: Union[bool, 'ProjectArgsFromStudentProjectRecursive3']


class StudentProjectIncludeFromStudentProjectRecursive3(TypedDict, total=False):
    """Relational arguments for StudentProject"""
    student: Union[bool, 'StudentArgsFromStudentProjectRecursive4']
    project: Union[bool, 'ProjectArgsFromStudentProjectRecursive4']


class StudentProjectIncludeFromStudentProjectRecursive4(TypedDict, total=False):
    """Relational arguments for StudentProject"""

    

class StudentProjectArgsFromStudentProject(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive1'


class StudentProjectArgsFromStudentProjectRecursive1(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive2'


class StudentProjectArgsFromStudentProjectRecursive2(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive3'


class StudentProjectArgsFromStudentProjectRecursive3(TypedDict, total=False):
    """Arguments for StudentProject"""
    include: 'StudentProjectIncludeFromStudentProjectRecursive4'


class StudentProjectArgsFromStudentProjectRecursive4(TypedDict, total=False):
    """Arguments for StudentProject"""
    
    

class FindManyStudentProjectArgsFromStudentProject(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive1'


class FindManyStudentProjectArgsFromStudentProjectRecursive1(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive2'


class FindManyStudentProjectArgsFromStudentProjectRecursive2(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive3'


class FindManyStudentProjectArgsFromStudentProjectRecursive3(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    include: 'StudentProjectIncludeFromStudentProjectRecursive4'


class FindManyStudentProjectArgsFromStudentProjectRecursive4(TypedDict, total=False):
    """Arguments for StudentProject"""
    take: int
    skip: int
    order_by: Union['StudentProjectOrderByInput', List['StudentProjectOrderByInput']]
    where: 'StudentProjectWhereInput'
    cursor: 'StudentProjectWhereUniqueInput'
    distinct: List['StudentProjectScalarFieldKeys']
    


FindManyStudentProjectArgs = FindManyStudentProjectArgsFromStudentProject
FindFirstStudentProjectArgs = FindManyStudentProjectArgsFromStudentProject


    

class StudentProjectWhereInput(TypedDict, total=False):
    """StudentProject arguments for searching"""
    StudentID: Union[_int, 'types.IntFilter']
    ProjectID: Union[_int, 'types.IntFilter']
    student: 'StudentRelationFilter'
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['StudentProjectWhereInputRecursive1', List['StudentProjectWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['StudentProjectWhereInputRecursive1']
    OR: List['StudentProjectWhereInputRecursive1']
    NOT: List['StudentProjectWhereInputRecursive1']


class StudentProjectWhereInputRecursive1(TypedDict, total=False):
    """StudentProject arguments for searching"""
    StudentID: Union[_int, 'types.IntFilter']
    ProjectID: Union[_int, 'types.IntFilter']
    student: 'StudentRelationFilter'
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['StudentProjectWhereInputRecursive2', List['StudentProjectWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['StudentProjectWhereInputRecursive2']
    OR: List['StudentProjectWhereInputRecursive2']
    NOT: List['StudentProjectWhereInputRecursive2']


class StudentProjectWhereInputRecursive2(TypedDict, total=False):
    """StudentProject arguments for searching"""
    StudentID: Union[_int, 'types.IntFilter']
    ProjectID: Union[_int, 'types.IntFilter']
    student: 'StudentRelationFilter'
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['StudentProjectWhereInputRecursive3', List['StudentProjectWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['StudentProjectWhereInputRecursive3']
    OR: List['StudentProjectWhereInputRecursive3']
    NOT: List['StudentProjectWhereInputRecursive3']


class StudentProjectWhereInputRecursive3(TypedDict, total=False):
    """StudentProject arguments for searching"""
    StudentID: Union[_int, 'types.IntFilter']
    ProjectID: Union[_int, 'types.IntFilter']
    student: 'StudentRelationFilter'
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['StudentProjectWhereInputRecursive4', List['StudentProjectWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['StudentProjectWhereInputRecursive4']
    OR: List['StudentProjectWhereInputRecursive4']
    NOT: List['StudentProjectWhereInputRecursive4']


class StudentProjectWhereInputRecursive4(TypedDict, total=False):
    """StudentProject arguments for searching"""
    StudentID: Union[_int, 'types.IntFilter']
    ProjectID: Union[_int, 'types.IntFilter']
    student: 'StudentRelationFilter'
    project: 'ProjectRelationFilter'



# aggregate StudentProject types


    

class StudentProjectScalarWhereWithAggregatesInput(TypedDict, total=False):
    """StudentProject arguments for searching"""
    StudentID: Union[_int, 'types.IntWithAggregatesFilter']
    ProjectID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['StudentProjectScalarWhereWithAggregatesInputRecursive1']
    OR: List['StudentProjectScalarWhereWithAggregatesInputRecursive1']
    NOT: List['StudentProjectScalarWhereWithAggregatesInputRecursive1']


class StudentProjectScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """StudentProject arguments for searching"""
    StudentID: Union[_int, 'types.IntWithAggregatesFilter']
    ProjectID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['StudentProjectScalarWhereWithAggregatesInputRecursive2']
    OR: List['StudentProjectScalarWhereWithAggregatesInputRecursive2']
    NOT: List['StudentProjectScalarWhereWithAggregatesInputRecursive2']


class StudentProjectScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """StudentProject arguments for searching"""
    StudentID: Union[_int, 'types.IntWithAggregatesFilter']
    ProjectID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['StudentProjectScalarWhereWithAggregatesInputRecursive3']
    OR: List['StudentProjectScalarWhereWithAggregatesInputRecursive3']
    NOT: List['StudentProjectScalarWhereWithAggregatesInputRecursive3']


class StudentProjectScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """StudentProject arguments for searching"""
    StudentID: Union[_int, 'types.IntWithAggregatesFilter']
    ProjectID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['StudentProjectScalarWhereWithAggregatesInputRecursive4']
    OR: List['StudentProjectScalarWhereWithAggregatesInputRecursive4']
    NOT: List['StudentProjectScalarWhereWithAggregatesInputRecursive4']


class StudentProjectScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """StudentProject arguments for searching"""
    StudentID: Union[_int, 'types.IntWithAggregatesFilter']
    ProjectID: Union[_int, 'types.IntWithAggregatesFilter']



class StudentProjectGroupByOutput(TypedDict, total=False):
    StudentID: _int
    ProjectID: _int
    _sum: 'StudentProjectSumAggregateOutput'
    _avg: 'StudentProjectAvgAggregateOutput'
    _min: 'StudentProjectMinAggregateOutput'
    _max: 'StudentProjectMaxAggregateOutput'
    _count: 'StudentProjectCountAggregateOutput'


class StudentProjectAvgAggregateOutput(TypedDict, total=False):
    """StudentProject output for aggregating averages"""
    StudentID: float
    ProjectID: float


class StudentProjectSumAggregateOutput(TypedDict, total=False):
    """StudentProject output for aggregating sums"""
    StudentID: _int
    ProjectID: _int


class StudentProjectScalarAggregateOutput(TypedDict, total=False):
    """StudentProject output including scalar fields"""
    StudentID: _int
    ProjectID: _int


StudentProjectMinAggregateOutput = StudentProjectScalarAggregateOutput
StudentProjectMaxAggregateOutput = StudentProjectScalarAggregateOutput


class StudentProjectMaxAggregateInput(TypedDict, total=False):
    """StudentProject input for aggregating by max"""
    StudentID: bool
    ProjectID: bool


class StudentProjectMinAggregateInput(TypedDict, total=False):
    """StudentProject input for aggregating by min"""
    StudentID: bool
    ProjectID: bool


class StudentProjectNumberAggregateInput(TypedDict, total=False):
    """StudentProject input for aggregating numbers"""
    StudentID: bool
    ProjectID: bool


StudentProjectAvgAggregateInput = StudentProjectNumberAggregateInput
StudentProjectSumAggregateInput = StudentProjectNumberAggregateInput


StudentProjectCountAggregateInput = TypedDict(
    'StudentProjectCountAggregateInput',
    {
        'StudentID': bool,
        'ProjectID': bool,
        '_all': bool,
    },
    total=False,
)

StudentProjectCountAggregateOutput = TypedDict(
    'StudentProjectCountAggregateOutput',
    {
        'StudentID': int,
        'ProjectID': int,
        '_all': int,
    },
    total=False,
)


StudentProjectKeys = Literal[
    'StudentID',
    'ProjectID',
    'student',
    'project',
]
StudentProjectScalarFieldKeys = Literal[
    'StudentID',
    'ProjectID',
]
StudentProjectScalarFieldKeysT = TypeVar('StudentProjectScalarFieldKeysT', bound=StudentProjectScalarFieldKeys)

StudentProjectRelationalFieldKeys = Literal[
        'student',
        'project',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields